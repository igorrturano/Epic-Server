use uo;
use os;
use datafile;
use util;
use guilds;
use file;
use math; // Adicionado para usar a função Abs

include "include/say";
include ":faccao:include/shared_functions";
include ":architect:include/systemclock";
include ":faccao:include/faccao_resources";
include ":faccao:include/logging";
include ":faccao:include/datafile_helpers"; // Nova inclusão



// Lista para rastrear o próximo território a ser verificado
var next_territory_checks := dictionary{};

program ResourceController()
    LogInfo("recursos", "Iniciando Controlador de Recursos de Territórios...");
    
    // Inicialização: construir agenda inicial
    InitializeSchedule();
    
    var check_interval := 30; // 30 segundos entre verificações
    
    while(1)
        // Verificar apenas territórios que estão próximos da hora de gerar recursos
        var current_time := polcore().systime;
        var territories_to_check := GetTerritoriesDueForCheck(current_time);
        
        foreach territory in (territories_to_check)
            var success := ProcessTerritory(territory, current_time);
            if (!success)
                // Se falhar, tentar novamente mais tarde
                RescheduleTerritory(territory, current_time + 60);
            endif
            sleepms(10); // Pequena pausa para não sobrecarregar
        endforeach
        
        Sleep(check_interval);
    endwhile
endprogram


function InitializeSchedule()
    var rect_df := SafeOpenDataFile(":architect:areas");
    if (!rect_df)
        return 0;
    endif
    
    var current_time := polcore().systime;
    
    foreach rect_name in (rect_df.keys())
        var elem := SafeFindElement(rect_df, rect_name);
        if (!elem)
            continue;
        endif
        
        var faction := GetElementProp(elem, "Faction");
        
        // Verificar apenas territórios controlados
        if (faction && faction != "Selvagem")
            var next_time := CInt(GetElementProp(elem, "NextResourceTime"));
            if (!next_time)
                // Se não tiver próxima verificação, configurar
                var interval := CInt(GetElementProp(elem, "ResourceInterval"));
                if (!interval) 
                    interval := 60; // Padrão: 60 minutos
                endif
                
                next_time := current_time + (interval * 60);
                SetElementProp(elem, "NextResourceTime", next_time);
            endif
            
            next_territory_checks[rect_name] := next_time;
        endif
        
        sleepms(5);
    endforeach
    
    return 1;
endfunction

function GetTerritoriesDueForCheck(current_time)
    var due_territories := array{};
    var window_size := 60; // 1 minuto de janela
    
    foreach territory_name in (next_territory_checks.keys())
        var check_time := next_territory_checks[territory_name];
        
        // Se está no intervalo de verificação
        if (check_time <= current_time + window_size)
            due_territories.append(territory_name);
        endif
        
        sleepms(2);
    endforeach
    
    return due_territories;
endfunction

function ProcessTerritory(territory_name, current_time)
    var rect_df := SafeOpenDataFile(":architect:areas");
    if (!rect_df)
        return 0;
    endif
    
    var elem := SafeFindElement(rect_df, territory_name);
    if (!elem)
        // Território não existe mais, remover da agenda
        next_territory_checks.Erase(territory_name);
        return 1;
    endif
    
    var next_time_prop := GetElementProp(elem, "NextResourceTime");
    var next_time := 0;

    if (next_time_prop)
        next_time := CInt(next_time_prop);
    endif

    if (next_time > current_time)
        return 1; // Ainda não é hora
    endif
    
    // Verificar e obter dados do território de forma robusta
    var faction := GetElementProp(elem, TERRITORY_FACTION_PROP);
    if (!faction)
        faction := GetElementProp(elem, "Faction"); // Compatibilidade legada
    endif
    
    var resource_interval := CInt(GetElementProp(elem, "ResourceInterval"));
    var resource_amount := CInt(GetElementProp(elem, "ResourceAmount"));
    var resources_string := GetElementProp(elem, "Resources");
    
    // Pré-processamento dos recursos para validação
    var resources := ProcessResourceString(resources_string);
    
    // Verificar validade dos dados
    var validade := VerificarValidadeDosDados(elem, faction, resources, resource_amount);
    if (!validade.valido)
        LogError("recursos", validade.mensagem);
        // Agendar tentativa futura e registrar falha
        RescheduleTerritory(territory_name, current_time + 300); // 5 minutos
        RegistrarFalhaDeCriacao(elem, faction, territory_name, resources_string);
        return 0;
    endif
    
    LogInfo("recursos", "Gerando recursos para território: " + territory_name);

    // Geração dos recursos com tratamento de erros mais detalhado
    var success := GenerateResourcesForTerritory(elem, faction, resource_amount);
    if (success)
        // Configurar próxima geração
        var next_gen_time := current_time + (resource_interval * 60);
        SetElementProp(elem, "NextResourceTime", next_gen_time);
        next_territory_checks[territory_name] := next_gen_time;
        
        LogInfo("recursos", "Próxima geração para " + territory_name + " agendada para daqui a " + resource_interval + " minutos");

        return 1;
    else
        // Tratar falha na geração
        LogError("recursos", "Falha ao gerar recursos para " + territory_name);
        
        // Verificar se devemos tentar criar um baú de emergência
        var emergency_result := TentarCriarBauEmergencia(faction, territory_name);
        if (emergency_result)
            LogWarning("recursos", "Baú de emergência criado. Reagendando geração de recursos.");
            // Agendar nova tentativa em breve
            RescheduleTerritory(territory_name, current_time + 120); // 2 minutos
            return 0;
        else
            // Falhou completamente, agendar para muito mais tarde
            LogCritical("recursos", "Impossível gerar recursos. Agendando nova tentativa para mais tarde.");

            RescheduleTerritory(territory_name, current_time + 3600); // 1 hora
            return 0;
        endif
    endif
    
    return 0;
endfunction

// Função de tentativa de criação de baú de emergência
function TentarCriarBauEmergencia(faction_name, territory_name)
    LogWarning("recursos", "Tentando criar baú de emergência para " + faction_name + " (Território: " + territory_name + ")");

    
    var emergency_chest := CreateEmergencyDonationChest(faction_name);
    if (emergency_chest)
        // Registrar associação com o território
        SetObjProperty(emergency_chest, "territory_id", territory_name);
        SetObjProperty(emergency_chest, "emergency_for_territory", territory_name);
        
        // Notificar administradores
        foreach player in EnumerateOnlineCharacters()
            if (player.cmdlevel >= 3)
                SendSysMessageEx(player, "SISTEMA: Baú de emergência criado para facção " + faction_name + 
                                 " devido a falhas de geração em " + territory_name, SSM_INFO);
            endif
        endforeach
        
        return 1;
    endif
    
    return 0;
endfunction

function RescheduleTerritory(territory_name, new_time)
    next_territory_checks[territory_name] := new_time;
    
    var rect_df := SafeOpenDataFile(":architect:areas");
    if (rect_df)
        var elem := SafeFindElement(rect_df, territory_name);
        if (elem)
            SetElementProp(elem, "NextResourceTime", new_time);
        endif
    endif
endfunction

function CheckTerritoryResources()
    var rect_df := SafeOpenDataFile(":architect:areas");
    if (!rect_df)
        return 0;
    endif
    
    var current_time := polcore().systime;
    
    foreach rect_name in (rect_df.keys())
        var elem := SafeFindElement(rect_df, rect_name);
        var faction := GetElementProp(elem, "Faction");
        
        // Verificar apenas territórios controlados
        if (faction && faction != "Selvagem")
            // Verificar se está na hora de gerar recursos
            var next_time := CInt(GetElementProp(elem, "NextResourceTime"));
            
            if (next_time && current_time >= next_time)
                var resource_interval := CInt(GetElementProp(elem, "ResourceInterval"));
                var resource_amount := CInt(GetElementProp(elem, "ResourceAmount"));
                var resources := GetElementProp(elem, "Resources");
                
                if (resource_interval && resource_amount && resources)
                    LogInfo("recursos", "Gerando recursos para território: " + rect_name + " (Facção: " + faction + ")");

                    
                    if (GenerateResourcesForTerritory(elem, faction, resource_amount))
                        // Configurar próxima geração
                        var next_gen_time := current_time + (resource_interval * 60); // Converter minutos para segundos
                        SetElementProp(elem, "NextResourceTime", next_gen_time);
                        
                        LogInfo("recursos", "Próxima geração para " + rect_name + " em " + resource_interval + " minutos");

                        
                        // Notificar líderes da facção
                        NotifyFactionLeaders(faction, rect_name, resources, resource_amount);
                    endif
                endif
            endif
        endif
        
        sleepms(10); // Pequena pausa para não sobrecarregar
    endforeach
    
    return 1;
endfunction

function GenerateResourcesForTerritory(elem, faction_name, resource_amount)
    if (!elem || !faction_name || resource_amount <= 0)
        LogError("recursos", "Parâmetros inválidos para geração de recursos");

        return 0;
    endif
    
    var territory_name;
    if (TypeOf(elem) == "String")
        territory_name := elem;
        var rect_df := SafeOpenDataFile(":architect:areas");
        if (!rect_df)
            LogError("recursos", "Não foi possível abrir o datafile de áreas");
            return 0;
        endif
        
        elem := SafeFindElement(rect_df, territory_name);
        if (!elem)
            LogError("recursos", "Território não encontrado: " + territory_name);
            return 0;
        endif
    else
        // Obter nome do território do elemento
        territory_name := GetElementProp(elem, "Name");
        if (!territory_name)
            territory_name := "Desconhecido";
        endif
    endif
    
    LogDebug("recursos", "Iniciando geração de recursos para território: " + territory_name);
    LogDebug("recursos", "Facção: " + faction_name + ", Quantidade: " + resource_amount);
    
    // Obter a facção de forma robusta
    var faction := GetElementProp(elem, TERRITORY_FACTION_PROP);
    if (!faction)
        faction := GetElementProp(elem, "Faction"); // Compatibilidade legada
    endif
    
    if (!faction)
        LogError("recursos", "Informação de facção inválida para o território");
        return 0;
    endif

    // Verificar se é selvagem
    if (faction == DEFAULT_FACTION || faction == "Selvagem")
        LogDebug("recursos", "Território selvagem, pulando geração de recursos");

        return 0;
    endif
    
    // Verificar se a facção passada corresponde à do território
    if (faction_name != faction)
        LogWarning("recursos", "Facção passada (" + faction_name + ") não corresponde à facção do território (" + faction + ")");

        // Usar a facção correta
        faction_name := faction;
    endif
    
    LogDebug("recursos", "Facção confirmada: " + faction_name);

    
    // Obter o ID do território
    var territory_id := GetElementProp(elem, TERRITORY_ID_PROP);
    if (!territory_id)
        territory_id := GetElementProp(elem, "Name"); // Fallback para nome do território
        LogDebug("recursos", "Usando nome do território como ID: " + territory_id);

    endif
    
    // Obter a string de recursos de forma segura
    var resources_string := GetElementProp(elem, "Resources");
    if (!resources_string)
        LogError("recursos", "Nenhum recurso configurado para o território");
        return 0;
    endif
    
    // Verificar o que está na string de recursos para depuração
    LogDebug("recursos", "String de recursos: " + resources_string);

    
    // Processar a lista de recursos com tratamento robusto
    var resources := ProcessResourceString(resources_string);
    
    if (!resources || resources.size() < 1)
        LogError("recursos", "Nenhum recurso válido encontrado após processamento");
        return 0;
    endif
    
    LogDebug("recursos", "" + resources.size() + " recursos válidos identificados");
    
    // Encontrar o baú de doações com tratamento de erros - USANDO TERRITORY_ID
    var donation_chest := FindFactionChest(faction_name, territory_id);
    if (!donation_chest)
        LogError("recursos", "Baú de doações não encontrado ou inacessível para facção: " + faction_name);
        
        // Tentar segunda busca apenas pela facção
        if (territory_id)
            LogDebug("recursos", "Tentando busca secundária apenas pela facção");
            donation_chest := FindFactionChest(faction_name);
        endif
        
        // Se ainda não encontrou, tentar criar um baú de emergência
        if (!donation_chest)
            LogWarning("recursos", "Criando baú de emergência para " + faction_name);
            donation_chest := CreateEmergencyDonationChest(faction_name);
            
            if (!donation_chest)
                LogCritical("recursos", "Impossível criar ou localizar baú de doações");
                return 0;
            endif
        endif
    endif
    
    // Verificar a validade do baú encontrado
    if (!IsValidContainer(donation_chest))
        LogError("recursos", "Baú de doações encontrado não é válido ou está inacessível");
        return 0;
    endif
    
    // Verificar se o baú tem espaço
    if (!HasContainerSpace(donation_chest, resources.size()))
        LogWarning("recursos", "Baú de doações pode estar cheio, alguns recursos podem não ser adicionados");
        // Continuar mesmo assim, tentando adicionar o que for possível
    endif
    
    LogDebug("recursos", "Iniciando adição de recursos ao baú " + donation_chest.serial);
    
    // Adicionar cada recurso com tratamento apropriado
    var success_count := 0;
    var log_entries := array{};
    
    foreach resource in (resources)
        LogDebug("recursos", "Processando recurso: " + resource);
        
        // Obter objtype do recurso
        var objtype := MapearRecurso(resource);
        if (!objtype)
            LogError("recursos", "Tipo de objeto não encontrado para recurso: " + resource);
            log_entries.append("Falha ao mapear recurso: " + resource);
            continue;
        endif
        
        // Obter categoria do recurso
        var category := ClassificarRecurso(resource);
        if (!category)
            LogWarning("recursos", "Categoria não determinada para recurso: " + resource + ", usando padrão");
            category := "metal"; // Valor padrão
        endif
        
        // Preparar as propriedades necessárias para o item
        var properties := dictionary{
            "IsKingdomDonation" + category   := 1,
            "GeneratedForTerritory"          := territory_name,
            "GeneratedTime"                  := polcore().systime,
            "GeneratedByFaction"             := faction_name,
            "CreatedByResourceController"    := 1,
            "faction"                        := faction_name,  // Importante para o baú ser reconhecido
            "territory_id"                   := territory_id   // Importante para território
        };
        
        // ABORDAGEM UNIFICADA: Usar SafeCreateItemInContainer
        var result := SafeCreateItemInContainer(donation_chest, objtype, resource_amount, properties);
        
        if (result)
            success_count += 1;
            log_entries.append("Recurso criado: " + resource + " x" + resource_amount);
            LogDebug("recursos", "Recurso adicionado com sucesso: " + resource + " x" + resource_amount);
        else
            // Tentar método alternativo se falhar
            LogWarning("recursos", "Falha ao criar item usando SafeCreateItemInContainer, tentando método direto");
            
            var new_item := CreateItemInContainer(donation_chest, objtype, resource_amount);
            if (new_item)
                // Aplicar todas as propriedades
                foreach prop_name in (properties.keys())
                    SetObjProperty(new_item, prop_name, properties[prop_name]);
                    sleepms(1);
                endforeach
                
                success_count += 1;
                log_entries.append("Recurso criado (método alternativo): " + resource + " x" + resource_amount);
                LogDebug("recursos", "Recurso adicionado com método alternativo: " + resource + " x" + resource_amount);;
            else
                log_entries.append("Falha ao criar recurso: " + resource);
                LogError("recursos", "Falha ao criar recurso: " + resource);
            endif
        endif
        
        sleepms(10); // Pequena pausa entre criações para não sobrecarregar
    endforeach
    
    // Registrar resultados
    if (success_count > 0)
        // Atualizar contagem de recursos do baú
        UpdateResourceCache(donation_chest);
        
        // Registrar a atividade no histórico do território
        var history := GetElementProp(elem, "ResourceHistory", array{});
        
        history.append(struct{
            "time" := polcore().systime,
            "resources" := resources,
            "amount" := resource_amount,
            "success" := success_count,
            "details" := log_entries,
            "chest_serial" := donation_chest.serial,
            "chest_name" := donation_chest.name
        });
        
        // Limitar o histórico a 10 entradas
        while (history.size() > 10)
            history.erase(1);
        endwhile
        
        SetElementProp(elem, "ResourceHistory", history);
        
        // Notificar líderes sobre o sucesso
        NotifyFactionLeadersOfResourceGeneration(faction_name, territory_name, resources, resource_amount, success_count);
    endif
    
    return success_count;
endfunction

// Função para notificar líderes sobre geração de recursos
function NotifyFactionLeadersOfResourceGeneration(faction_name, territory_name, resources, amount, success_count)
    var guild := FindGuildByName(faction_name);
    if (!guild || guild == error)
        return 0;
    endif
    
    var leader_serials := array{};
    
    // Adicionar o líder da facção
    var leader_serial := guild.GetProp("leader");
    if (leader_serial)
        leader_serials.append(leader_serial);
    endif
    
    // Buscar oficiais online
    foreach player in EnumerateOnlineCharacters()
        // Verificar se é da mesma facção
        if (player.guildid == guild.guildid)
            // Verificar se tem cargo de oficial
            var player_rank := GetObjProperty(player, "guild_rank");
            if (player_rank in {"Lider", "Capitao", "Tenente", "Leader", "Captain", "Lieutenant"})
                if (!(player.serial in leader_serials))
                    leader_serials.append(player.serial);
                endif
            endif
            
            // Verificar se tem título de nobreza
            var chardata := GetObjProperty(player, "chardata");
            if (chardata && (chardata.current_nobility_title in {"Rei", "Rainha"} || 
                chardata.current_professional_position in {"Imperador", "Mão do Rei"}))
                if (!(player.serial in leader_serials))
                    leader_serials.append(player.serial);
                endif
            endif
        endif
    endforeach
    
    // Se não encontramos nenhum líder online, retornar
    if (leader_serials.size() == 0)
        return 0;
    endif
    
    // Criar uma mensagem adequada
    var resource_names := "";
    for i := 1 to resources.size()
        if (i > 1)
            resource_names += ", ";
        endif
        
        if (i == resources.size() && i > 1)
            resource_names += "e ";
        endif
        
        resource_names += resources[i];
    endfor
    
    var message := "Milord, um carregamento de recursos (";
    message += resource_names + ", " + amount + " unidades de cada) ";
    message += "produzido em '" + territory_name + "' chegou aos portões";
    
    if (success_count < resources.size())
        message += ". " + success_count + " dos " + resources.size() + " tipos de recursos foram armazenados.";
    else
        message += " e foi armazenado nos devidos baús.";
    endif
    
    // Enviar a mensagem para cada líder
    foreach serial in (leader_serials)
        var leader := SystemFindObjectBySerial(serial);
        if (leader && leader != error && leader.connected)
            SendSysMessageEx(leader, message, SSM_INFO);
        endif
    endforeach
    
    return leader_serials.size();
endfunction

// Função para atualizar o cache de recursos do baú
function UpdateResourceCache(chest)
    if (!chest)
        return 0;
    endif
    
    // Marcar o baú para atualização
    SetObjProperty(chest, "recursos_cache_dirty", 1);
    
    // Agendar atualização
    var result := AgendarAtualizacaoBau(chest);
    if (result == error)
        LogError("recursos", "Falha ao agendar atualização para o baú");
        return 0;
    endif
    return result;
endfunction

// Função para notificar líderes de facção
function NotifyFactionLeaders(faction_name, territory_name, resources_string, amount)
    var guild := FindGuildByName(faction_name);
    if (!guild || guild == error)
        return 0;
    endif
    var leader_serials := array{};
    
    // Adicionar o líder da facção
    var leader_serial := guild.GetProp("leader");
    if (leader_serial)
        leader_serials.append(leader_serial);
    endif
    
    // Buscar todos os jogadores online que possuem os títulos específicos
    foreach player in (EnumerateOnlineCharacters())
        var chardata := GetObjProperty(player, "chardata");
        if (chardata && chardata != error)
            // Verificar se o jogador tem um dos títulos específicos e pertence à mesma facção
            if (player.guildid == guild.guildid && 
               (chardata.current_nobility_title in {"Rei", "Rainha"} || 
                chardata.current_professional_position in {"Imperador", "Mão do Rei"}))
                // Adicionar apenas se ainda não estiver na lista
                if (!(player.serial in leader_serials))
                    leader_serials.append(player.serial);
                endif
            endif
        endif
    endforeach
    
    // Se não encontramos nenhum líder online, retornar
    if (leader_serials.size() == 0)
        return 0;
    endif
    
    // Separar recursos individuais e enviar uma mensagem para cada
    // Usar a nova função para tratar recursos com vírgulas
    var resources := SplitResourcesString(resources_string);
    
    foreach serial in (leader_serials)
        var leader := SystemFindObjectBySerial(serial);
        if (leader && leader != error && leader.connected)
            foreach resource in (resources)
                // Validar o recurso
                resource := Trim(resource);
                if (resource == "")
                    continue;
                endif
                
                var message := "Milord, um carregamento de " + resource + " (x" + amount + ") produzido em '" + 
                                territory_name + "' chegou aos portões e já foi colocado nos devidos baús.";
                SendSysMessageEx(leader, message, SSM_INFO);
                sleepms(200); // Pequena pausa entre mensagens para o mesmo jogador
            endforeach
        endif
    endforeach
    
    return leader_serials.size();
endfunction


// Função para atualizar a contagem de recursos diretamente no baú
function AtualizarContagemRecursos(bau, force_update := 0)
    // Registrar início para depuração
    LogDebug("recursos", "AtualizarContagemRecursos() iniciada para baú: " + bau.serial);
    
    // Obter último timestamp de atualização
    var ultimo_update := GetObjProperty(bau, "recursos_ultimo_update");
    var current_time := polcore().systime;
    
    // Se a última atualização foi recente e não estamos forçando nova contagem, usar o cache
    if (!force_update && ultimo_update && (current_time - ultimo_update < 300))
        LogDebug("recursos", "Usando cache - última atualização há " + (current_time - ultimo_update) + " segundos");
        var recursos_cache := GetObjProperty(bau, "recursos_cache");
        if (recursos_cache)
            return recursos_cache;
        endif
    endif
    
    // Realizar contagem completa
    LogDebug("recursos", "Realizando contagem completa dos recursos no baú");
    var recursos := ContarRecursosReais(bau);
    
    // Verificar inconsistências se houver cache anterior
    var recursos_cache := GetObjProperty(bau, "recursos_cache");
    if (recursos_cache)
        // Usar a função consolidada com o parâmetro 'nivel' como "local"
        var inconsistencias := VerificarInconsistencias(bau, recursos, "local");
        
        // Registrar o resultado para depuração
        if (inconsistencias.size() > 0)
            LogDebug("recursos", "Encontradas " + inconsistencias.size() + " inconsistências no baú");
        endif
    endif
    
    // Atualizar o cache no baú
    SetObjProperty(bau, "recursos_cache", recursos);
    SetObjProperty(bau, "recursos_ultimo_update", current_time);
    LogDebug("recursos", "Cache atualizado no baú");
    
    // Verificar se devemos atualizar o datafile global também
    var ultima_sync := GetObjProperty(bau, "recursos_ultima_sync");
    if (!ultima_sync || (current_time - ultima_sync > 1800) || force_update)
        // Se passou mais de 30 minutos da última sincronização ou estamos forçando
        SincronizarComDataFileLocal(bau, recursos);
        SetObjProperty(bau, "recursos_ultima_sync", current_time);
        LogDebug("recursos", "Datafile global atualizado");
    else
        LogDebug("recursos", "Datafile global não atualizado - última sync há " + (current_time - ultima_sync) + " segundos");
        // Agendar atualização futura se necessário
        AgendarAtualizacaoDataFileLocal(bau);
    endif
    
    return recursos;
endfunction

// Sincronizar dados com o datafile global
function SincronizarComDataFileLocal(container, recursos)
    var faction_name := GetObjProperty(container, OBJ_FACTION_PROP);
    
    if (!faction_name)
        LogError("recursos", "Nome da facção não fornecido para busca de baú");
        return 0;
    endif
    
    if (faction_name == KINGDOM_FACTION || faction_name == "Reino")
        // Atualizar recursos do reino no datafile principal
        var df := SafeOpenDataFile(KINGDOM_RESOURCE_DATAFILE, 1);
        var elem := SafeFindElement(df, KINGDOM_RESOURCE_ELEM, 1);
        SetElementProp(elem, "recursos", recursos);
    else
        // Atualizar recursos da facção em seu próprio elemento no datafile
        var df := SafeOpenDataFile(KINGDOM_RESOURCE_DATAFILE, 1);
        var elem := SafeFindElement(df, "faction_" + faction_name, 1);
        SetElementProp(elem, "recursos", recursos);
        
        // Atualizar também nas propriedades da guilda
        var guild := FindGuildByName(faction_name);
        if (guild)
            var guild_obj := FindGuild(guild);
            if (guild_obj)
                guild_obj.SetProp("recursos", recursos);
            endif
        endif
    endif
    
    return 1;
endfunction


// Registrar falha de criação
function RegistrarFalhaDeCriacao(elem, faction_name, territory_name, recursos_falhos)
    // Registrar no log
    LogError("recursos", "Falha ao criar recursos para " + territory_name + " (Facção: " + faction_name + ")");
    LogError("recursos", "Recursos falhos: " + recursos_falhos);
    
    // Adicionar ao histórico de falhas do território
    var history := GetElementProp(elem, "ResourceFailHistory", array{});
    
    history.append(struct{
        "time" := polcore().systime,
        "failed_resources" := recursos_falhos,
        "faction" := faction_name
    });
    
    // Limitar o histórico a 10 entradas
    while (history.size() > 10)
        history.erase(1);
    endwhile
    
    SetElementProp(elem, "ResourceFailHistory", history);
    
    // Tentar notificar os administradores
    NotificarAdministradoresFalhaRecursos(faction_name, territory_name, recursos_falhos);
    
    return 1;
endfunction

// Notificar administradores sobre falhas de recursos
function NotificarAdministradoresFalhaRecursos(faction_name, territory_name, recursos_falhos)
    var mensagem := "SISTEMA: Falha ao gerar recursos em " + territory_name + 
                    " (Facção: " + faction_name + "). Recursos falhos: " + recursos_falhos;
    
    // Enviar para todos os GMs online
    foreach player in EnumerateOnlineCharacters()
        if (player.cmdlevel >= 3)
            SendSysMessageEx(player, mensagem, SSM_FAIL);
        endif
    endforeach
    
    // Registrar em um datafile específico para consulta posterior
    var df := SafeOpenDataFile(":faccao:resource_failures", 1);
    if (df)
        var elem := SafeFindElement(df, "log", 1);
        var logs := GetElementProp(elem, "entries", array{});
        
        logs.append(struct{
            "time" := polcore().systime,
            "faction" := faction_name,
            "territory" := territory_name,
            "failed_resources" := recursos_falhos
        });
        
        // Limitar o tamanho do log
        while (logs.size() > 100)
            logs.erase(1);
        endwhile
        
        SetElementProp(elem, "entries", logs);
    endif
    
    return 1;
endfunction

// Processar revogações de territórios
function ProcessRevocations()
    // Verifica se há notificações de revogação
    var df := SafeOpenDataFile(":system:messages");
    if (df)
        var elem := SafeFindElement(df, "resource_controller");
        if (elem)
            var revocations := GetElementProp(elem, "revocations");
            if (revocations)
                foreach territorio in revocations
                    if (territorio && territorio != error)
                        LogDebug("recursos", "Processando revogação de território: " + territorio);
                        
                        // Remover do registro de recursos
                        var territorio_elem := FindElement(territorio);  // Renomeado para evitar conflito
                        if (territorio_elem && territorio_elem != error)
                            territorio_elem.EraseProp("NextResourceTime");
                            LogDebug("recursos", "Propriedade NextResourceTime removida para: " + territorio);
                        endif
                        
                        // Procurar o objeto existente que corresponde a este território
                        var item := FindExistingStackableItem(territorio);
                        if (item && item != error)
                            LogDebug("recursos", "Item existente encontrado para: " + territorio);
                            // Processar o item...
                        endif
                        
                        // Quaisquer outras ações necessárias
                    endif
                    sleepms(2); // Prevenir congelamento do servidor
                endforeach
                
                // Limpar a lista após processar
                SetElementProp(elem, "revocations", array{});
            endif
        endif
    endif
    
    // Também verificar diretamente o status de territórios agendados
    foreach territorio in (next_territory_checks.keys())
        var rect_df := SafeOpenDataFile(":architect:areas");
        if (rect_df)
            var elem := SafeFindElement(rect_df, territorio);
            if (elem)
                var faction := GetElementProp(elem, TERRITORY_FACTION_PROP);
                // Se o território agora é selvagem, remover do agendamento
                if (!faction || faction == DEFAULT_FACTION)
                    next_territory_checks.Erase(territorio);
                    LogInfo("recursos", "Território " + territorio + " agora é selvagem, removido do agendamento");
                endif
            endif
        endif
        sleepms(2);
    endforeach
    
    return 1;
endfunction

function VerificarValidadeDosDados(elem, faction, resources, resource_amount)
    var validade := struct{
        "valido" := 1,
        "mensagem" := ""
    };
    
    if (!elem)
        validade.valido := 0;
        validade.mensagem := "Elemento inválido";
        return validade;
    endif
    
    if (!faction || faction == "Selvagem" || faction == DEFAULT_FACTION)
        validade.valido := 0;
        validade.mensagem := "Facção inválida ou território selvagem";
        return validade;
    endif
    
    if (!resources || !resources.size())
        validade.valido := 0;
        validade.mensagem := "Nenhum recurso válido configurado";
        return validade;
    endif
    
    if (resource_amount <= 0)
        validade.valido := 0;
        validade.mensagem := "Quantidade de recursos inválida";
        return validade;
    endif
    
    return validade;
endfunction

function ParseResourceList(resources_string)
    if (!resources_string)
        return array{};
    endif
    
    // Remover espaços extras
    resources_string := Trim(resources_string);
    
    // Se contém vírgulas, dividir por vírgulas
    if (resources_string.find(",") != error)
        var resources := array{};
        var parts := SplitWords(resources_string, ",");
        
        foreach part in parts
            part := Trim(part);
            if (part != "")
                resources.append(part);
            endif
            sleepms(1);
        endforeach
        
        return resources;
    endif
    
    // Se não contém vírgulas, talvez seja apenas um recurso ou separado por espaços
    var space_parts := SplitWords(resources_string);
    
    if (space_parts.size() > 1)
        return space_parts;
    endif
    
    // Se chegou aqui, é apenas um recurso
    return array{resources_string};
endfunction

// Adicionar também a função auxiliar SplitResourcesString
function SplitResourcesString(resources_string)
    return ParseResourceList(resources_string);
endfunction