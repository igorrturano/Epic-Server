// ==========================================================================
// PROCESSADOR DE ATUALIZAÇÕES DE RECURSOS
// Arquivo: :faccao:process_recursos_updates.src
// ==========================================================================
//
// Este script processa as atualizações pendentes de recursos de facções
// em lotes, evitando o impacto de processamento no servidor durante períodos
// de alta atividade dos jogadores.
//
// Versão: 2.0 - Processamento centralizado
// ==========================================================================

use os;
use uo;
use datafile;
use math; // Adicionado para usar a função Abs

include ":faccao:include/shared_functions";
include ":faccao:include/faccao_resources";
include ":faccao:faccao_constants";
include ":faccao:include/logging";
include ":faccao:include/datafile_helpers";  // Nova inclusão

// Constantes configuráveis
const MAX_ITEMS_PER_CYCLE := 10;       // Máximo de itens processados por ciclo
const CYCLE_WAIT_TIME := 60;           // Segundos entre ciclos de processamento
const EMERGENCY_CYCLE_TIME := 300;     // Tempo para ciclo de emergência (segundos)
const PRIORITY_THRESHOLD := 1800;      // Tempo (segundos) para considerar prioridade
const MAX_PROCESSING_TIME := 60;       // Tempo máximo (segundos) para processar um baú

program ProcessRecursosUpdates()
    LogInfo("recursos", "Iniciando processador de atualizações de recursos (Versão Simplificada)...");
    
    // Registrar PID para que outros scripts possam verificar se está rodando
    SetGlobalProperty("recursos_update_processor_pid", GetPid());
    
    // Loop principal simplificado
    while (1)
        // Obter lista de atualizações pendentes
        var updates_pending := GetGlobalProperty("recursos_updates_pending");
        
        // Verificar se há atualizações pendentes
        if (updates_pending && updates_pending.keys().size() > 0)
            ProcessarAtualizacoesPendentes(updates_pending);
            
            // Atualizar a propriedade global
            SetGlobalProperty("recursos_updates_pending", updates_pending);
        endif
        
        // Verificar novamente após um tempo
        Sleep(60); // 1 minuto entre ciclos
    endwhile
endprogram


// Função simplificada para processar baú individual
function ProcessarBau(bau)
    // Verificar se é válido
    if (!bau || !bau.isA(POLCLASS_CONTAINER))
        return 0;
    endif
    
    // Verificar se o baú está sendo usado no momento
    if (GetObjProperty(bau, "being_processed"))
        return 0;
    endif
    
    // Marcar como em processamento
    SetObjProperty(bau, "being_processed", polcore().systime);
    
    // Processar o baú
    var success := 0;
    
    // Contar recursos no baú
    var recursos_reais := ContarRecursosReais(bau);
    
    // Atualizar o cache
    SetObjProperty(bau, CACHE_PROP_NAME, recursos_reais);
    SetObjProperty(bau, CACHE_UPDATE_PROP, polcore().systime);
    EraseObjProperty(bau, CACHE_DIRTY_FLAG);
    
    // Sincronizar com datafile
    var faction_name := GetObjProperty(bau, OBJ_FACTION_PROP);
    if (faction_name)
        success := SincronizarComDataFile(bau, recursos_reais);
    endif
    
    // Limpar flag de processamento
    EraseObjProperty(bau, "being_processed");
    
    return success;
endfunction

// Função principal para processar atualizações pendentes
function ProcessarAtualizacoesPendentes(byref updates_pending)
    LogInfo("recursos", "Iniciando processador centralizado de atualizações de recursos...");
    
    // Rastrear métricas para logging
    var total_processado := 0;
    var total_erro := 0;
    var tempo_inicio := polcore().systime;
    
    // Organizar por prioridade
    var sorted_serials := OrganizarAtualizacoesPorPrioridade(updates_pending);
    
    // Processar baús (limitado por ciclo)
    var items_processed := 0;
    var current_time := polcore().systime;
    
    foreach serial in sorted_serials
        var bau := SystemFindObjectBySerial(CInt(serial));
        
        if (bau)
            var tempo_enfileirado := current_time - updates_pending[serial];
            
            LogInfo("recursos", "Processando baú #" + serial + " (Tempo em fila: " + tempo_enfileirado + "s)");
            
            // Definir tempo limite para processamento
            var start_time := polcore().systime;
            var result := ProcessarBauComTimeout(bau, MAX_PROCESSING_TIME);
            var processing_time := polcore().systime - start_time;
            
            if (result)
                total_processado += 1;
                LogInfo("recursos", "Baú #" + serial + " processado com sucesso em " + processing_time + "s");
            else
                total_erro += 1;
                LogError("recursos", "Falha ao processar baú #" + serial + " após " + processing_time + "s");
                
                // Se falhou por timeout, reagendar com baixa prioridade
                if (processing_time >= MAX_PROCESSING_TIME)
                    updates_pending[serial] := current_time - (PRIORITY_THRESHOLD / 2);
                    LogWarning("recursos", "Baú #" + serial + " reagendado devido a timeout");
                    continue; // Não remover da lista
                endif
            endif
        else
           LogError("recursos", "Baú #" + serial + " não encontrado");
            total_erro += 1;
        endif
        
        // Remover da lista de pendências
        updates_pending.erase(serial);
        
        // Controle de quantidade por ciclo
        items_processed += 1;
        if (items_processed >= MAX_ITEMS_PER_CYCLE)
            LogInfo("recursos", "Limite de " + MAX_ITEMS_PER_CYCLE + " itens por ciclo atingido. Continuando no próximo ciclo.");
            break;
        endif
        
        Sleep(2); // Breve pausa entre atualizações para não sobrecarregar
    endforeach
    
    // Atualizar a lista global
    SetGlobalProperty("recursos_updates_pending", updates_pending);
    
    // Registrar métricas
    var tempo_total := polcore().systime - tempo_inicio;
    LogInfo("recursos", "Processamento de ciclo concluído em " + tempo_total + "s. Processados: " + 
           total_processado + ", Erros: " + total_erro + ", Restantes: " + updates_pending.keys().size());
    
    // Salvar estatísticas
    SalvarEstatisticasProcessamento(total_processado, total_erro, tempo_total, updates_pending.keys().size());
    
    return total_processado;
endfunction

// Função para organizar atualizações por prioridade
function OrganizarAtualizacoesPorPrioridade(updates_pending)
    var priorities := dictionary{};
    var current_time := polcore().systime;
    
    // Classificar cada baú por prioridade
    foreach serial in (updates_pending.keys())
        var enqueued_time := updates_pending[serial];
        var time_in_queue := current_time - enqueued_time;
        
        // Prioridade alta: baús na fila há muito tempo
        if (time_in_queue > PRIORITY_THRESHOLD)
            if (!priorities.exists("high"))
                priorities["high"] := array{};
            endif
            priorities["high"].append(serial);
        else
            // Prioridade normal
            if (!priorities.exists("normal"))
                priorities["normal"] := array{};
            endif
            priorities["normal"].append(serial);
        endif
    endforeach
    
    // Combinar as listas, com alta prioridade primeiro
    var sorted_serials := array{};
    
    if (priorities.exists("high"))
        foreach serial in (priorities["high"])
            sorted_serials.append(serial);
        endforeach
    endif
    
    if (priorities.exists("normal"))
        foreach serial in (priorities["normal"])
            sorted_serials.append(serial);
        endforeach
    endif
    
    return sorted_serials;
endfunction

// Função para processar um baú com timeout
function ProcessarBauComTimeout(bau, timeout_seconds)
    var start_time := polcore().systime;
    
    // Verificar periperties básicas para determinar se é válido
    if (!bau || !bau.isA(POLCLASS_CONTAINER) || bau.objtype != 0xFF11)
        return 0;
    endif
    
    // Verificar se o baú está sendo usado no momento
    if (GetObjProperty(bau, "being_processed"))
        LogWarning("recursos", "Baú #" + bau.serial + " já está sendo processado, pulando");
        return 0;
    endif
    
    // Marcar como em processamento
    SetObjProperty(bau, "being_processed", polcore().systime);
    
    // Processar o baú
    var success := 0;
    
    // Primeira etapa: Corrigir inconsistências
    var inconsistencias := VerificarEResolverInconsistencias(bau);
    
    // Segunda etapa: Forçar sincronização se necessário
    if (inconsistencias > 0)
        LogWarning("recursos", "Encontradas " + inconsistencias + " inconsistências no baú #" + bau.serial);
        success := ForcarSincronizacaoBau(bau);
    else
        // Se não há inconsistências, apenas verificar se precisa sincronizar
        var last_sync := GetObjProperty(bau, DATAFILE_SYNC_PROP);
        var current_time := polcore().systime;
        
        if (!last_sync || (current_time - last_sync > DATAFILE_UPDATE_INTERVAL))
            LogInfo("recursos", "Baú #" + bau.serial + " precisa sincronização periódica");
            success := ForcarSincronizacaoBau(bau);
        else
            // Não precisa sincronizar agora
            LogInfo("recursos", "Baú #" + bau.serial + " verificado, não precisa sincronização");
            success := 1;
        endif
    endif
    
    // Limpar flag de processamento
    EraseObjProperty(bau, "being_processed");
    
    return success;
endfunction

// Função para executar um ciclo de emergência (verificação geral)
function ExecutarCicloEmergencia()
    LogInfo("recursos", "Executando ciclo de emergência para verificar integridade dos recursos...");
    
    // Verificar facções importantes
    VerificarFaccoesImportantes();
    
    // Verificar inconsistências no datafile
    VerificarIntegridadeDatafile();
    
    LogInfo("recursos", "Ciclo de emergência concluído");
endfunction

// Função para verificar facções importantes
function VerificarFaccoesImportantes()
    // Verificar primeiro o Reino
    VerificarRecursosDoReino();
    
    // Verificar facções ativas
    var guilds := ListGuilds();
    foreach guild_id in guilds
        var guild := FindGuild(guild_id);
        if (guild && guild.members.size() > 0)
            var faction_name := guild.GetProp("name");
            if (!faction_name)
                faction_name := guild.guildname;
            endif
            
            if (faction_name)
                VerificarRecursosDaFaccao(faction_name, guild);
            endif
        endif
        Sleep(1);
    endforeach
endfunction

// Função para verificar recursos do Reino
function VerificarRecursosDoReino()
    // Verificar recursos no datafile
    var df := SafeOpenDataFile(KINGDOM_RESOURCE_DATAFILE, 1);
    if (df)
        var elem := SafeFindElement(df, KINGDOM_RESOURCE_ELEM, 1);
        var recursos := GetElementProp(elem, "recursos");
        
        if (!recursos)
            // Se não há recursos definidos, criar struct vazio
            recursos := CreateEmptyResourceStruct();
            SetElementProp(elem, "recursos", recursos);
            LogInfo("recursos", "Inicializado struct de recursos do Reino");
        else
            // Validar e corrigir se necessário
            var recursos_validados := ValidarRecursos(recursos);
            
            // Se houve alterações durante a validação
            if (!SaoRecursosIguais(recursos, recursos_validados))
                SetElementProp(elem, "recursos", recursos_validados);
                LogWarning("recursos", "Corrigidos recursos inválidos do Reino");
            endif
        endif
    endif
    
    // Verificar baús do Reino
    foreach item in EnumerateItemsInContainer(0)
        if (item.objtype == 0xFF11 && 
            (GetObjProperty(item, OBJ_FACTION_PROP) == KINGDOM_FACTION || 
             GetObjProperty(item, OBJ_FACTION_PROP) == "Reino"))
             
            // Verificar e corrigir inconsistências
            VerificarEResolverInconsistencias(item);
            
            // Verificar sincronização
            var last_sync := GetObjProperty(item, DATAFILE_SYNC_PROP);
            var current_time := polcore().systime;
            
            if (!last_sync || (current_time - last_sync > DATAFILE_UPDATE_INTERVAL))
                ForcarSincronizacaoBau(item);
            endif
        endif
        Sleep(1);
    endforeach
endfunction

// Função para verificar recursos de uma facção
function VerificarRecursosDaFaccao(faction_name, guild := 0)
    if (!faction_name)
        return 0;
    endif
    
    // Verificar recursos no datafile
    var df := SafeOpenDataFile(KINGDOM_RESOURCE_DATAFILE, 1);
    if (df)
        var elem := SafeFindElement(df, "faction_" + faction_name, 1);
        var recursos := GetElementProp(elem, "recursos");
        
        if (!recursos)
            // Se não há recursos definidos, criar struct vazio
            recursos := CreateEmptyResourceStruct();
            SetElementProp(elem, "recursos", recursos);
            LogInfo("recursos", "Inicializado struct de recursos da facção: " + faction_name);
        else
            // Validar e corrigir se necessário
            var recursos_validados := ValidarRecursos(recursos);
            
            // Se houve alterações durante a validação
            if (!SaoRecursosIguais(recursos, recursos_validados))
                SetElementProp(elem, "recursos", recursos_validados);
                LogWarning("recursos", "Corrigidos recursos inválidos da facção: " + faction_name);
            endif
        endif
    endif
    
    // Verificar baús da facção
    foreach item in EnumerateItemsInContainer(0)
        if (item.objtype == 0xFF11 && GetObjProperty(item, OBJ_FACTION_PROP) == faction_name)
            // Verificar e corrigir inconsistências
            VerificarEResolverInconsistencias(item);
            
            // Verificar sincronização
            var last_sync := GetObjProperty(item, DATAFILE_SYNC_PROP);
            var current_time := polcore().systime;
            
            if (!last_sync || (current_time - last_sync > DATAFILE_UPDATE_INTERVAL))
                ForcarSincronizacaoBau(item);
            endif
            
            // Atualizar registro na guilda
            if (guild)
                RegisterFactionChest(faction_name, item, guild);
            endif
        endif
        Sleep(1);
    endforeach
    
    return 1;
endfunction

// Função para registrar baú de facção na guilda
function RegisterFactionChest(faction_name, chest, guild)
    if (!faction_name || !chest || !guild)
        return 0;
    endif
    
    // Verificar se o serial já está registrado
    var current_chest := guild.GetProp("donation_chest");
    
    // Se não há registro ou o baú registrado não existe mais
    if (!current_chest || !SystemFindObjectBySerial(current_chest))
        guild.SetProp("donation_chest", chest.serial);
        LogInfo("recursos", "Baú #" + chest.serial + " registrado para facção: " + faction_name);
        
        // Também registrar no datafile específico
        var df := SafeOpenDataFile("faction_chests", 1);
        var elem := SafeFindElement(df, faction_name, 1);
        
        SetElementProp(elem, "chest_serial", chest.serial);
        SetElementProp(elem, "location", struct{
            "x" := chest.x,
            "y" := chest.y,
            "z" := chest.z,
            "realm" := chest.realm
        });
        SetElementProp(elem, "last_update", polcore().systime);
    endif
    
    return 1;
endfunction

// Função auxiliar para comparar dois structs de recursos
function SaoRecursosIguais(recursos1, recursos2)
    if (!recursos1 || !recursos2)
        return 0;
    endif
    
    return (recursos1.comida == recursos2.comida &&
            recursos1.moedas == recursos2.moedas &&
            recursos1.couro == recursos2.couro &&
            recursos1.metal == recursos2.metal &&
            recursos1.madeira == recursos2.madeira &&
            recursos1.pano == recursos2.pano &&
            recursos1.pedras == recursos2.pedras &&
            recursos1.joias == recursos2.joias);
endfunction

// Função para salvar estatísticas de processamento
function SalvarEstatisticasProcessamento(processados, erros, tempo, pendentes)
    var df := SafeOpenDataFile("resource_stats", 1);
    var elem := SafeFindElement(df, "processamento", 1);
    
    var history := GetElementProp(elem, "ciclos", array{});
    
    // Adicionar nova entrada
    history.append(struct{
        "timestamp" := polcore().systime,
        "processados" := processados,
        "erros" := erros,
        "tempo" := tempo,
        "pendentes" := pendentes
    });
    
    // Limitar o tamanho do histórico
    while (history.size() > 50)
        history.erase(1);
    endwhile
    
    SetElementProp(elem, "ciclos", history);
    
    // Atualizar estatísticas agregadas
    var stats := GetElementProp(elem, "totais", struct{
        "total_processados" := 0,
        "total_erros" := 0,
        "total_ciclos" := 0,
        "tempo_total" := 0,
        "ultimo_ciclo" := 0
    });
    
    stats.total_processados += processados;
    stats.total_erros += erros;
    stats.total_ciclos += 1;
    stats.tempo_total += tempo;
    stats.ultimo_ciclo := polcore().systime;
    
    SetElementProp(elem, "totais", stats);
    
    return 1;
endfunction