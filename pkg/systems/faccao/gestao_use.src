use uo;
use os;
use cfgfile;
use util;
use guilds;

include ":gumps:gumps";
include ":gumps:gumps_ex";
include ":gumps:htmlGump";
include ":faccao:faccao";
include ":datafile:datafile";
include "include/say";
include "include/arrays";
include ":tn:tngumps";
include ":faccao:include/shared_functions";
include ":faccao:faccao_constants";
include ":faccao:include/faccao_resources";
include ":faccao:include/permissions";
include ":faccao:include/logging";



const BKGND_BLUESLAB := 9200;
const BKGND_STONESLAB := 3500;

const BOTAO_REINO := 1;
const BOTAO_LEIS := 2;
const BOTAO_FACCOES := 3;
const BOTAO_DOACOES := 4;
const BOTAO_CONSTRUCOES := 5;
const BOTAO_GUERRA := 6;

const MENU_INTRO := 0;
const MENU_REINO := 1;
const MENU_LEIS := 2;
const MENU_FACCOES := 3;
const MENU_DOACOES := 4;
const MENU_CONSTRUCOES := 5;
const MENU_GUERRA := 6;
var button_states := array{0, 0, 0, 0, 0, 0};

// Controle de depuração global - 0 = desligado, 1 = ligado
var DEBUG_GESTAO := 0;

program gestao_use(who, item)
    if (!who || !item)
        SendSysMessage(who, "Erro: who ou item é nulo");
        return 0;
    endif

      if (!CanAccessGestao(who, item))
        SendSysMessage(who, "Você não tem permissão para acessar a interface de gestão");
        return 0;
    endif
    
    SendSysMessage(who, "Acessando interface de gestão do Reino");
    ShowKingdomManagementGump(who, item);
    
    return 1;
endprogram

function CanAccessGestao(who, item)
    // Usar sistema de permissões centralizado
    return CheckPermission(who, item, "access");
endfunction

function ShowKingdomManagementGump(who, item)
    var cur_menu := MENU_DOACOES;
    var continuar := 1;

    while(continuar)
        var gump := CreateKingdomManagementGump(who, cur_menu, item);
        var input := GFSendGump(who, gump);
        
        if (input[0] >= 700 && input[0] < 900)
            // Ações de território sempre finalizam o loop
            ProcessarAcaoTerritorio(who, input[0], item);
            return; // Saída imediata e definitiva
        elseif (input[0] != 0)
            cur_menu := AtualizarEstadoMenu(input[0]);
        else
            continuar := 0; // Sair do loop se o usuário fechar o gump
        endif
    endwhile
endfunction

function CreateKingdomManagementGump(who, cur_menu, item)
    var gump := CriarLayoutBase();
    
    case (cur_menu)
        MENU_REINO:
            ReinoGump(gump, item);  // Passar o item (mesa de gestão) para ReinoGump
        MENU_LEIS:
            LeisGump(gump);
        MENU_FACCOES:
            FaccoesGump(gump);
        MENU_DOACOES:
            DoacoesGump(gump, item);
        MENU_CONSTRUCOES:
            ConstrucoesGump(gump);
        MENU_GUERRA:
            GuerraGump(gump);
        default:
            DoacoesGump(gump, item);
    endcase

    return gump;
endfunction

function CriarLayoutBase()
    var gump := GFCreateGump();
    
    GFGumpPicTiled(gump, 19, 19, 759, 550, 39929);
    AdicionarMoldura(gump);
    GFGumpPicTiled(gump, 32, 24, 733, 29, 9354);
    AdicionarBotoesNavegacao(gump);
    
    return gump;
endfunction

function AdicionarMoldura(byref gump)
    var molduras := array{
        struct{ x := 0, y := 5, width := 35, height := 36, gump := 39925 },
        struct{ x := 33, y := 5, width := 729, height := 21, gump := 39926 },
        struct{ x := 0, y := 41, width := 21, height := 539, gump := 39928 },
        struct{ x := 759, y := 5, width := 35, height := 36, gump := 39927 },
        struct{ x := 759, y := 36, width := 37, height := 534, gump := 39930 },
        struct{ x := 0, y := 561, width := 37, height := 33, gump := 39931 },
        struct{ x := 33, y := 561, width := 730, height := 33, gump := 39932 },
        struct{ x := 759, y := 561, width := 36, height := 33, gump := 39933 },
        struct{ x := 444, y := 60, width := 8, height := 502, gump := 39928 }
    };

foreach moldura in (molduras)
    GFGumpPicTiled(gump, moldura.x, moldura.y, moldura.width, moldura.height, moldura.gump);
endforeach
endfunction

function AdicionarBotoesNavegacao(byref gump)
    var textos := array{"Reino", "Leis", "Facções", "Doações", "Construções", "Guerra"};
    var x_positions := array{85, 185, 285, 395, 505, 635};
    var botoes := array{BOTAO_REINO, BOTAO_LEIS, BOTAO_FACCOES, BOTAO_DOACOES, BOTAO_CONSTRUCOES, BOTAO_GUERRA};
    
    for i := 1 to 6
        var gump_button := 2151;
        var text_color := 53;
        
        if (button_states[i])
            gump_button := 2153;
            text_color := 230;
        endif
        
        GFTextLine(gump, x_positions[i], 27, text_color, textos[i]);
        GFAddButton(gump, x_positions[i] - 35, 23, gump_button, gump_button, GF_CLOSE_BTN, botoes[i]);
    endfor
endfunction

function AtualizarEstadoMenu(input)
    case (input)
        BOTAO_REINO:
            button_states := array{1, 0, 0, 0, 0, 0};
            return MENU_REINO;
        BOTAO_LEIS:
            button_states := array{0, 1, 0, 0, 0, 0};
            return MENU_LEIS;
        BOTAO_FACCOES:
            button_states := array{0, 0, 1, 0, 0, 0};
            return MENU_FACCOES;
        BOTAO_DOACOES:
            button_states := array{0, 0, 0, 1, 0, 0};
            return MENU_DOACOES;
        BOTAO_CONSTRUCOES:
            button_states := array{0, 0, 0, 0, 1, 0};
            return MENU_CONSTRUCOES;
        BOTAO_GUERRA:
            button_states := array{0, 0, 0, 0, 0, 1};
            return MENU_GUERRA;
        default:
            return MENU_DOACOES;
    endcase
endfunction

function ReinoGump(byref gump, item)
    LogDebug("territorio", "Iniciando ReinoGump");

    GFResizePic(gump, 38, 60, 40267, 400, 502);
    
    // Obter a facção da mesa de gestão
    var mesa_faction := GetObjProperty(item, OBJ_FACTION_PROP);
    
    // Título personalizado com o nome da facção
    var titulo := mesa_faction ? "Gestão de " + mesa_faction : "Gestão do Reino";
    GFTextMid(gump, 490, 60, 263, 2100, titulo);
    
    var rect_df := SafeOpenDataFile(":architect:areas");
    if (rect_df)
        // Criar lista de territórios visíveis baseados na mesa_faction
        var territorios_visiveis := array{};
        
        foreach elem_name in (rect_df.keys())
            var elem := SafeFindElement(rect_df, elem_name);
            
            // Verificar propriedades de facção
           var faction := GetElementProp(elem, TERRITORY_FACTION_PROP, "");
            if (!faction || faction == error)
                faction := GetElementProp(elem, "Faction", "");
            endif
            
            // Obter ID do território
            var territory_id := GetElementProp(elem, TERRITORY_ID_PROP, "");
            if (!territory_id)
                territory_id := elem_name; // Compatibilidade retroativa
            endif
            
            // Filtrar por facção
            if (faction && faction != DEFAULT_FACTION && 
                (!mesa_faction || mesa_faction == KINGDOM_FACTION || faction == mesa_faction))
                territorios_visiveis.append(struct{
                    "name" := elem_name,
                    "id" := territory_id,
                    "faction" := faction
                });
            endif
            sleepms(2);
        endforeach
        
        // Criar um único background para a área de territórios
        GFResizePic(gump, 460, 100, 9350, 320, 300);
        
        // Adicionar cabeçalhos
        GFTextLine(gump, 485, 105, 53, "Nome do Terreno");
        GFTextLine(gump, 690, 105, 53, "Info");
        GFTextLine(gump, 730, 105, 53, "Aliados");
        
        var y := 140; // Começar após os cabeçalhos
        var territorios_mostrados := 0;
        
        foreach territorio in (territorios_visiveis)
            // Verificar se é capital
            var is_capital := IsTerritoryCapital(territorio.id);
            
            // Número do território
            GFTextLine(gump, 470, y+5, 2100, territorios_mostrados+1 + ".");
            
            // Se for capital, adicionar coroa ou marcador especial
            if (is_capital)
                GFTextLine(gump, 485, y+5, 230, territorio.name + " [CAPITAL]"); // Texto em cor diferente
            else
                GFTextLine(gump, 485, y+5, 53, territorio.name);
            endif
            
            // Botões de informação e aliados
            GFAddButton(gump, 693, y+5, 0x4B9, 0x4BA, GF_CLOSE_BTN, 700 + territorios_mostrados);
            GFAddButton(gump, 740, y+5, 0x4B9, 0x4BA, GF_CLOSE_BTN, 800 + territorios_mostrados);
            
            y += 35; // Espaçamento entre territórios
            territorios_mostrados += 1;
            
            // Limite para não sobrecarregar a interface
            if (territorios_mostrados >= 10)
                break;
            endif
            
            sleepms(2);
        endforeach
        
        if (territorios_mostrados == 0)
            var msg := mesa_faction ? 
                       "Não há territórios controlados por " + mesa_faction + "." :
                       "Não há territórios controlados por facções.";
            GFTextMid(gump, 540, 200, 150, 38, msg);
        endif
    else
        GFTextMid(gump, 620, 200, 150, 38, "Sistema de territórios indisponível.");
    endif
    
    return gump;
endfunction

function ProcessarAcaoTerritorio(who, input, item)
    if (input >= 700 && input < 800)
        // Botão de visualizar mapa do território
        var territorio_idx := input - 700;
        MostrarMapaTerritorio(who, territorio_idx, item);
        return 0; // Retornar 0 para continuar no gump
    elseif (input >= 800 && input < 900)
        // Botão de informações do território
        var territorio_idx := input - 800;
        var resultado := MostrarInformacoesTerritorio(who, territorio_idx, item);
        return resultado; // Retornar o resultado da operação
    endif
    
    return 0; // Padrão: continuar no gump
endfunction

function MostrarMapaTerritorio(who, index, item)
    var rect_df := SafeOpenDataFile(":architect:areas");
    if (!rect_df) 
        return SendSysMessage(who, "Sistema de territórios indisponível.");
    endif
    
    // Obter a facção da mesa de gestão
    var mesa_faction := GetObjProperty(item, OBJ_FACTION_PROP);
    
    var territorios := array{};
    foreach elem_name in (rect_df.keys())
        var elem := SafeFindElement(rect_df, elem_name);
        
        // Verificar propriedades de facção
        var faction := GetElementProp(elem, TERRITORY_FACTION_PROP, "");
        if (!faction || faction == error)
            faction := GetElementProp(elem, "Faction", "");
        endif
        
        // Filtrar por facção da mesa
        if (faction && faction != DEFAULT_FACTION && 
            (!mesa_faction || mesa_faction == KINGDOM_FACTION || faction == mesa_faction))
            territorios.append(elem_name);
        endif
        sleepms(2);
    endforeach
    
    // Verificar se o índice é válido
    if (index < 0 || index >= territorios.size())
        return SendSysMessage(who, "Território não encontrado. Índice: " + index + ", Total: " + territorios.size());
    endif
    
    var territorio := territorios[index+1]; // Ajustando para indexação baseada em 1
    var elem := SafeFindElement(rect_df, territorio);
    
    // Mostrar as coordenadas no mapa
    var rect := GetElementProp(elem, "Rect", "");
    var coords := SplitWords(rect);
    
    var gump := GFCreateGump();
    GFResizePic(gump, 0, 0, 9200, 400, 300);
    GFResizePic(gump, 15, 15, 9350, 370, 270);
    
    GFTextMid(gump, 20, 25, 370, 2100, "Mapa do Território: " + territorio);
    var y := 60;
    if (coords.size() >= 4)
        var x1 := CInt(coords[1]);
        var y1 := CInt(coords[2]);
        var x2 := CInt(coords[3]);
        var y2 := CInt(coords[4]);
        GFTextLine(gump, 30, y, 2100, "Coordenadas: ");
        GFTextLine(gump, 110, y, 53, rect);
        GFTextLine(gump, 30, y+20, 2100, "Facção: ");
        GFTextLine(gump, 110, y+20, 53, GetElementProp(elem, TERRITORY_FACTION_PROP, ""));
        
        // Botão de teleporte removido conforme solicitado
    endif
    
    GFAddButton(gump, 150, 250, 2128, 2129, GF_CLOSE_BTN, 0);
    
    var input := GFSendGump(who, gump);
    
    // Remover o processamento do botão de teleporte
endfunction

function LeisGump(byref gump)
    GFResizePic(gump, 38, 60, 40266, 400, 502);
    GFTextMid(gump, 490, 60, 263, 2100, "Sistema de Leis");
    // TODO: Adicionar conteúdo relacionado às leis do reino
endfunction

function FaccoesGump(byref gump)
    GFResizePic(gump, 38, 60, 40264, 400, 502);
    GFTextMid(gump, 490, 60, 263, 2100, "Gerenciamento de Facções");
    // TODO: Adicionar conteúdo relacionado às facções
endfunction

function DoacoesGump(byref gump, item)
    GFResizePic(gump, 38, 60, 40260, 400, 502);
    
    // Obter o nome da facção para personalizar o título
    var faction_name := GetObjProperty(item, OBJ_FACTION_PROP);
    var titulo := faction_name ? "Recursos de " + faction_name : "Recursos do Reino";
    
    GFTextMid(gump, 490, 60, 263, 2100, titulo);
    
    // Passar o item para a função
    var recursos := ObterRecursosBau(item);
    CriarLayoutDoacoes(gump, recursos);
endfunction

function ConstrucoesGump(byref gump)
    GFResizePic(gump, 38, 60, 40263, 400, 502);
    GFTextMid(gump, 490, 60, 263, 2100, "Gerenciamento de Construções");
    // TODO: Adicionar conteúdo relacionado às construções do reino
endfunction

function GuerraGump(byref gump)
    GFResizePic(gump, 38, 60, 40265, 400, 502);
    GFTextMid(gump, 490, 60, 263, 2100, "Sistema de Guerra");
    // TODO: Adicionar conteúdo relacionado ao sistema de guerra
endfunction

function CriarLayoutDoacoes(byref gump, recursos)
    if (!gump)
        return 0;
    endif

    GFGumpPicTiled(gump, 466, 60, 263, 21, 9354);
    AdicionarQuadradosRecursos(gump);
    AdicionarIconesItens(gump);
    GFTextLine(gump, 541, 60, 53, "Recursos do Reino");
    AdicionarTextosTiposDoacao(gump);
    AdicionarValoresRecursos(gump, recursos);

    return 1;
endfunction

function AdicionarQuadradosRecursos(byref gump)
    var quadrados := array{
        struct{ "x" := 466, "y" := 98 },
        struct{ "x" := 630, "y" := 97 },
        struct{ "x" := 467, "y" := 220 },
        struct{ "x" := 630, "y" := 217 },
        struct{ "x" := 466, "y" := 338 },
        struct{ "x" := 630, "y" := 335 },
        struct{ "x" := 466, "y" := 456 },
        struct{ "x" := 630, "y" := 456 }
    };

foreach quadrado in (quadrados)
    GFGumpPicTiled(gump, quadrado.x, quadrado.y, 98, 78, 9354);
    GFGumpPicTiled(gump, quadrado.x, quadrado.y + 85, 98, 21, 9394);
endforeach
endfunction

function AdicionarIconesItens(byref gump)
    var itens := array{
        struct{ "x" := 490, "y" := 124, "grafico" := 29807 },
        struct{ "x" := 655, "y" := 132, "grafico" := 3823 },
        struct{ "x" := 492, "y" := 247, "grafico" := 4225 },
        struct{ "x" := 659, "y" := 242, "grafico" := 29421 },
        struct{ "x" := 493, "y" := 361, "grafico" := 7135 },
        struct{ "x" := 660, "y" := 364, "grafico" := 5991 },
        struct{ "x" := 495, "y" := 485, "grafico" := 4963 },
        struct{ "x" := 652, "y" := 493, "grafico" := 41779 }
    };

foreach item in (itens)
    GFTilePic(gump, item.x, item.y, item.grafico);
endforeach
endfunction

function AdicionarTextosTiposDoacao(byref gump)
    var tipos := array{
        struct{ "x" := 498, "y" := 99, "texto" := RESOURCE_TYPE_COMIDA },
        struct{ "x" := 660, "y" := 101, "texto" := RESOURCE_TYPE_MOEDAS },
        struct{ "x" := 498, "y" := 219, "texto" := RESOURCE_TYPE_COURO },
        struct{ "x" := 660, "y" := 220, "texto" := RESOURCE_TYPE_METAL },
        struct{ "x" := 492, "y" := 338, "texto" := RESOURCE_TYPE_MADEIRA },
        struct{ "x" := 660, "y" := 340, "texto" := RESOURCE_TYPE_PANO },
        struct{ "x" := 498, "y" := 456, "texto" := RESOURCE_TYPE_PEDRA },
        struct{ "x" := 660, "y" := 459, "texto" := RESOURCE_TYPE_JOIAS }
    };

foreach tipo in (tipos)
    GFTextLine(gump, tipo.x, tipo.y, 53, tipo.texto);
endforeach
endfunction

function AdicionarValoresRecursos(byref gump, recursos)
    if (!gump || !recursos)
        return 0;
    endif

    var posicoes := array{
        struct{ "x" := 503, "y" := 184, "valor" := recursos.comida },
        struct{ "x" := 667, "y" := 184, "valor" := recursos.moedas },
        struct{ "x" := 503, "y" := 304, "valor" := recursos.couro },
        struct{ "x" := 667, "y" := 304, "valor" := recursos.metal },
        struct{ "x" := 503, "y" := 424, "valor" := recursos.madeira },
        struct{ "x" := 667, "y" := 424, "valor" := recursos.pano },
        struct{ "x" := 503, "y" := 541, "valor" := recursos.pedras },
        struct{ "x" := 667, "y" := 541, "valor" := recursos.joias }
    };

foreach pos in (posicoes)
    GFTextLine(gump, pos.x, pos.y, 53, CStr(pos.valor));
endforeach

    return 1;
endfunction

function ObterRecursosBau(item)
    if (DEBUG_GESTAO)
        LogDebug("recursos", "ObterRecursosBau() iniciada para item: " + item.serial);
    endif

    // Obter propriedades fundamentais do item
    var faction_name := GetObjProperty(item, OBJ_FACTION_PROP);
    
    if (!faction_name || faction_name == error)
        if (DEBUG_GESTAO)
            LogWarning("recursos", "Mesa de gestão sem facção definida - Serial: " + item.serial);
        endif
        return CreateEmptyResourceStruct();
    endif
    
    // Se for mesa do Reino, obter recursos gerais
    if (faction_name == KINGDOM_FACTION || faction_name == "Reino")
        return ObterRecursosFaccao();
    endif
    
    // Buscar baú para esta facção
    var chest := FindFactionChest(faction_name);
    
    if (chest)
        if (DEBUG_GESTAO)
            LogDebug("recursos", "Baú encontrado para facção: " + faction_name);
        endif
        return ContarItensDoadosNoBau(chest);
    endif
    
    // Se não encontrou baú, retornar struct vazio
    if (DEBUG_GESTAO)
        LogWarning("recursos", "Nenhum baú encontrado para a facção: " + faction_name);
    endif
    return CreateEmptyResourceStruct();
endfunction



function MostrarInformacoesTerritorio(who, index, item)
    if (DEBUG_GESTAO)
        LogDebug("territorio", "Iniciando função MostrarInformacoesTerritorio, index: " + index);
    endif
    
    var rect_df := SafeOpenDataFile(":architect:areas");
    if (!rect_df) 
        SendSysMessage(who, "Sistema de territórios indisponível.");
        return 0;
    endif
    
    // Obter a facção da mesa de gestão
    var mesa_faction := GetObjProperty(item, OBJ_FACTION_PROP);
    
    // Coletar territórios visíveis para esta facção
    var territorios := array{};
    foreach elem_name in (rect_df.keys())
        var elem := SafeFindElement(rect_df, elem_name);
        
        // Verificar propriedades de facção
        var faction := GetElementProp(elem, TERRITORY_FACTION_PROP, "");
        if (!faction)
            faction := GetElementProp(elem, "Faction", ""); // Compatibilidade
        endif
        
        // Obter ID do território
        var territory_id := GetElementProp(elem, TERRITORY_ID_PROP, "");
        if (!territory_id)
            territory_id := elem_name; // Compatibilidade retroativa
        endif
        
        // Filtrar por facção
        if (faction && faction != DEFAULT_FACTION && 
            (!mesa_faction || mesa_faction == KINGDOM_FACTION || faction == mesa_faction))
            territorios.append(struct{
                "name" := elem_name,
                "id" := territory_id,
                "elem" := elem
            });
        endif
        sleepms(2);
    endforeach
    
    // Verificação de índice
    if (index < 0 || index >= territorios.size())
        SendSysMessage(who, "Território não encontrado.");
        return 0;
    endif
    
    // Obter o território pelo índice (ajustado para indexação baseada em 1)
    var territorio := territorios[index+1];
    if (!territorio)
        SendSysMessage(who, "Nome do território inválido.");
        return 0;
    endif
    
    var elem := territorio.elem;
    if (!elem)
        SendSysMessage(who, "Elemento do território não encontrado.");
        return 0;
    endif
    
    // Obter propriedades
    var faction := GetElementProp(elem, TERRITORY_FACTION_PROP, "");
    if (!faction)
        faction := GetElementProp(elem, "Faction", "");
    endif
    if (!faction) faction := "Desconhecida"; endif
    
    var rect := GetElementProp(elem, "Rect", "");
    if (!rect) rect := "Desconhecidas"; endif
    
    var realm := GetElementProp(elem, "Realm", "");
    if (!realm) realm := "Desconhecido"; endif
    
    // Mostrar interface de informações
    MostrarGumpInformacoesTerritorio(who, territorio, faction, rect, realm, item);
    
    return 1;
endfunction

function MostrarGumpInformacoesTerritorio(who, territorio, faction, rect, realm, item)
    // Criar gump
    var gump := GFCreateGump();
    GFResizePic(gump, 0, 0, 9200, 400, 350);
    GFResizePic(gump, 15, 15, 9350, 370, 320);
    
    GFTextLine(gump, 30, 25, 2100, "Informações do Território:");
    
    var y := 60;
    
    GFTextLine(gump, 30, y, 2100, "Nome: ");
    GFTextLine(gump, 85, y, 53, territorio.name);
    y += 20;
    
    GFTextLine(gump, 30, y, 2100, "ID: ");
    GFTextLine(gump, 85, y, 53, territorio.id);
    y += 20;
    
    GFTextLine(gump, 30, y, 2100, "Facção: ");
    GFTextLine(gump, 85, y, 53, faction);
    y += 20;
    
    GFTextLine(gump, 30, y, 2100, "Coordenadas: ");
    GFTextLine(gump, 140, y, 53, rect);
    y += 20;
    
    GFTextLine(gump, 30, y, 2100, "Realm: ");
    GFTextLine(gump, 85, y, 53, realm);
    y += 30;
    
    // Opções administrativas (apenas para GM ou Rei)
    var chardata := GetObjProperty(who, "chardata");
    if (who.cmdlevel >= 3 || (chardata && (chardata.current_nobility_title in {"Rei", "Rainha"})))
        GFTextLine(gump, 30, y, 2100, "Ações Administrativas:");
        y += 20;
        
        GFAddButton(gump, 30, y, 2117, 2118, GF_CLOSE_BTN, 1);
        GFTextLine(gump, 50, y, 53, "Revogar controle da facção");
        y += 25;
        
        GFAddButton(gump, 30, y, 2117, 2118, GF_CLOSE_BTN, 2);
        GFTextLine(gump, 50, y, 53, "Transferir para outra facção");
        y += 25;
        
        // Nova opção para definir como capital
        var is_capital := IsTerritoryCapital(territorio.id);
        var capital_text := is_capital ? "Remover status de Capital" : "Definir como Capital";
        GFAddButton(gump, 30, y, 2117, 2118, GF_CLOSE_BTN, 3);
        GFTextLine(gump, 50, y, 53, capital_text);
    endif
    
    GFAddButton(gump, 150, 300, 2128, 2129, GF_CLOSE_BTN, 0);
    
    var input := GFSendGump(who, gump);
    
    // Processar escolha
    ProcessarAcaoTerritorioGump(who, input[0], territorio, faction, item);
endfunction
function ProcessarAcaoTerritorioGump(who, choice, territorio, faction, item)
    if (choice == 0)
        return 0;
    endif
    
    if (choice == 1)
        // Revogar controle
        RevogarTerritorioFaccao(who, territorio.elem, territorio, faction);
    elseif (choice == 2)
        // Transferir para outra facção
        TransferirTerritorioFaccao(who, territorio.elem, territorio, faction);
    elseif (choice == 3)
        // Toggle status de capital - CORREÇÃO: passa faction como parâmetro
        ToggleStatusCapital(who, territorio, item);
    endif
    
    return 1;
endfunction

function ToggleStatusCapital(who, territorio, item)
    var is_capital := IsTerritoryCapital(territorio.id);
    
    if (is_capital)
        // Remover status
        var territory_elem := FindTerritoryByID(territorio.id);
        if (territory_elem)
            territory_elem.EraseProp(TERRITORY_IS_CAPITAL_PROP);
            SendSysMessage(who, "Status de Capital removido do território.");
        endif
    else
        // Verificar se a mesa está associada a uma facção específica
        var mesa_faction := GetObjProperty(item, OBJ_FACTION_PROP);
        if (!mesa_faction)
            // CORREÇÃO: Obter a facção do território em vez de usar uma variável indefinida
            var territorio_faction := "";
            if (territorio.elem)
                territorio_faction := GetObjProperty(territorio.elem, TERRITORY_FACTION_PROP);
                if (!territorio_faction)
                    territorio_faction := GetObjProperty(territorio.elem, "Faction"); // Compatibilidade
                endif
            endif
            
            mesa_faction := territorio_faction ? territorio_faction : "Desconhecida";
        endif
        
        if (SetTerritoryAsCapital(territorio.id, mesa_faction))
            SendSysMessage(who, "Território definido como Capital de " + mesa_faction + "!");
        else
            SendSysMessage(who, "Falha ao definir território como Capital.");
        endif
    endif
endfunction

function TransferirTerritorioFaccao(who, elem, territorio_info, old_faction)
    LogDebug("territorio", "Iniciando transferência de território com proteção de transações");
    var seriais_df := SafeOpenDataFile(":faccao:seriais");
    // Garantir compatibilidade com ambos os formatos
    var territorio_id := TypeOf(territorio_info) == "Struct" ? territorio_info.id : territorio_info;
    var territorio_nome := TypeOf(territorio_info) == "Struct" ? territorio_info.name : territorio_info;
    
    LogDebug("territorio", "Território identificado - ID: " + territorio_id + ", Nome: " + territorio_nome);
    
    // Montar lista de facções
    var gump := GFCreateGump();
    GFResizePic(gump, 0, 0, 9200, 400, 300);
    GFResizePic(gump, 15, 15, 9350, 370, 270);
    
    GFTextMid(gump, 15, 25, 380, 53, "Escolha a facção para transferir " + territorio_nome);
    
    var y := 60;
    var guilds := ListGuilds();
    LogDebug("territorio", "Total de guildas encontradas: " + guilds.size());
    
    var guild_names := array{};
    var button_id := 1;
    
    foreach guild in (guilds)
        var name := guild.GetProp(FACTION_PROP_NAME);
        if (!name || name == error)
            name := guild.GetProp("name");
            if (!name || name == error)
                name := guild.guildname;
            endif
        endif
        
        if (name && name != old_faction)
            guild_names.append(name);
            GFAddButton(gump, 30, y, 2117, 2118, GF_CLOSE_BTN, button_id);
            GFTextLine(gump, 60, y, 1153, name);
            y += 25;
            button_id += 1;
        endif
        sleepms(2);
    endforeach
    
    // Adicionar opção Cancelar
    GFAddButton(gump, 30, y + 20, 2117, 2118, GF_CLOSE_BTN, 0);
    GFTextLine(gump, 60, y + 20, 2100, "Cancelar");
    
    // Enviar gump e obter resposta
    var input := GFSendGump(who, gump);
    var choice := input[0];
    
    // Se clicou em Cancelar ou fechou o gump
    if (choice == 0)
        return 0;
    endif
    
    // Obter a facção selecionada pelo índice do botão
    var new_faction := guild_names[choice];
    
    if (YesNo(who, "Transferir controle de " + territorio_nome + " para " + new_faction + "?"))
        // Iniciar uma transação para operação atômica
        var transaction_data := struct{
            "territorio_id" := territorio_id,
            "territorio_nome" := territorio_nome,
            "faccao_original" := old_faction,
            "faccao_nova" := new_faction
        };
        
        // Capturar seriais dos objetos originais para possível reversão
        var rect_df := SafeOpenDataFile(":architect:areas");
        if (seriais_df)
            var territorios_seriais := seriais_df.GetProp("territorios");
            if (territorios_seriais && territorios_seriais[territorio_id])
                transaction_data.seriais_originais := territorios_seriais[territorio_id];
            endif
        endif
        
        // Iniciar a transação
        var transaction_id := IniciarTransacao("transferir_territorio", transaction_data);
        if (transaction_id == error)
            SendSysMessage(who, "Erro ao iniciar transação. Transferência cancelada.");
            return 0;
        endif
        
        SendSysMessage(who, "Processando: Iniciando transferência de território...");
        
        // ===== ETAPA 1: LIMPAR OS OBJETOS EXISTENTES =====
        SendSysMessage(who, "Processando: Removendo objetos existentes...");
        
        var territorio_realm := GetElementProp(elem, "Realm", "");
        if (!territorio_realm)
            territorio_realm := "britannia"; // Padrão se não encontrar
        endif
        
        var script := start_script(":faccao:limpa_territorio", array{territorio_id, old_faction, who, territorio_realm});
        if (script == error)
            SendSysMessage(who, "Erro ao iniciar o script de limpeza: " + script);
            DesfazerTransacao(transaction_id);
            return 0;
        endif
        
        // Aguardar limpeza ser concluída
        Sleep(3);
        
        // ===== ETAPA 2: ATUALIZAR O DATAFILE DE ÁREAS =====
        SetElementProp(elem, "Faction", new_faction);
        SetElementProp(elem, TERRITORY_FACTION_PROP, new_faction);
        
        // ===== ETAPA 3: ATUALIZAR AS GUILDAS =====
        
        // 3.1 Remover da facção antiga
        var old_guild := FindGuildByName(old_faction);
        if (old_guild)
            var old_guild_obj := FindGuild(old_guild);
            if (old_guild_obj)
                var old_territories := old_guild_obj.GetProp("territories");
                if (old_territories)
                    // Criar nova lista sem o território removido
                    var new_old_territories := array{};
                    foreach terr in old_territories
                        if (terr != territorio_id && terr != territorio_nome)
                            new_old_territories.append(terr);
                        endif
                        sleepms(2);
                    endforeach
                    
                    old_guild_obj.SetProp("territories", new_old_territories);
                endif
            endif
        endif
        
        // 3.2 Adicionar à nova facção
        var new_guild := FindGuildByName(new_faction);
        if (new_guild)
            var new_guild_obj := FindGuild(new_guild);
            if (new_guild_obj)
                var new_territories := new_guild_obj.GetProp("territories");
                if (!new_territories)
                    new_territories := array{};
                endif
                
                // Verificar se já existe
                var exists := 0;
                foreach terr in new_territories
                    if (terr == territorio_id || terr == territorio_nome)
                        exists := 1;
                        break;
                    endif
                    sleepms(2);
                endforeach
                
                if (!exists)
                    new_territories.append(territorio_id);
                endif
                
                new_guild_obj.SetProp("territories", new_territories);
            endif
        endif
        
        // ===== ETAPA 4: CRIAR NOVOS OBJETOS PARA A NOVA FACÇÃO =====
        SendSysMessage(who, "Processando: Criando novos objetos para a facção...");
        
        // Obter coordenadas do território
        var coords := SplitWords(GetElementProp(elem, "Rect", ""));
       var realm := GetElementProp(elem, "Realm", "");
        
        if (coords.size() >= 4)
            var x1 := CInt(coords[1]);
            var y1 := CInt(coords[2]);
            var x2 := CInt(coords[3]);
            var y2 := CInt(coords[4]);
            
            // Calcular o centro do território
            var center_x := CInt((x1 + x2) / 2);
            var center_y := CInt((y1 + y2) / 2);
            var center_z := GetMapInfo(center_x, center_y, realm).z;
            
            // 4.1 Criar o baú
            var chest := CreateItemAtLocation(center_x, center_y, center_z, 0xFF11, 1, realm);
            if (!chest)
                DesfazerTransacao(transaction_id);
                SendSysMessage(who, "Erro ao criar baú. Transferência revertida.");
                return 0;
            endif
            
            chest.movable := 0;
            SetObjProperty(chest, OBJ_FACTION_PROP, new_faction);
            SetObjProperty(chest, "FactionName", new_faction);
            SetObjProperty(chest, TERRITORY_ID_PROP, territorio_id);
            
            var chest_id := new_faction + "_" + territorio_id;
            SetObjProperty(chest, CHEST_ID_PROP, chest_id);
            
            var nome_bau := "Baú de Doações de " + new_faction;
            if (territorio_id)
                nome_bau += " - " + territorio_id;
            endif
            SetName(chest, nome_bau);
            
            chest.usescript := ":faccao:baudoacao/use";
            SetObjProperty(chest, "OnInsertScript", ":faccao:baudoacao/onInsert");
            SetObjProperty(chest, "OnRemoveScript", ":faccao:baudoacao/onRemove");
            SetObjProperty(chest, "CanInsertScript", ":faccao:baudoacao/canInsert");
            SetObjProperty(chest, "CanRemoveScript", ":faccao:baudoacao/canRemoveDonation");
            
            // 4.2 Criar a mesa de gestão
            var table := CreateItemAtLocation(center_x+1, center_y, center_z, 0xFE5C, 1, realm);
            if (!table)
                DesfazerTransacao(transaction_id);
                DestroyItem(chest); // Limpar o baú criado
                SendSysMessage(who, "Erro ao criar mesa de gestão. Transferência revertida.");
                return 0;
            endif
            
            table.movable := 0;
            SetObjProperty(table, OBJ_FACTION_PROP, new_faction);
            SetObjProperty(table, "FactionName", new_faction);
            SetObjProperty(table, TERRITORY_ID_PROP, territorio_id);
            
            var nome_mesa := "Mesa de Gestão de " + new_faction;
            if (territorio_id)
                nome_mesa += " - " + territorio_id;
            endif
            SetName(table, nome_mesa);
            
            table.usescript := ":faccao:gestao_use";
            
            // 4.3 Criar o mural de recrutamento
            var mural := CreateItemAtLocation(center_x, center_y+1, center_z, 0x46AE, 1, realm);
            if (!mural)
                DesfazerTransacao(transaction_id);
                DestroyItem(chest);
                DestroyItem(table);
                SendSysMessage(who, "Erro ao criar mural. Transferência revertida.");
                return 0;
            endif
            
            mural.movable := 0;
            SetObjProperty(mural, OBJ_FACTION_PROP, new_faction);
            SetObjProperty(mural, "FactionName", new_faction);
            SetObjProperty(mural, TERRITORY_ID_PROP, territorio_id);
            
            var nome_mural := "Mural de Recrutamento de " + new_faction;
            if (territorio_id)
                nome_mural += " - " + territorio_id;
            endif
            SetName(mural, nome_mural);
            
            mural.usescript := ":faccao:faccao";
            
            // 4.4 Salvar os seriais no datafile
            var rect_df := SafeOpenDataFile(":architect:areas");
            if (seriais_df == error)
                seriais_df := SafeOpenDataFile(":faccao:seriais", 1);
            endif
            
            if (seriais_df && seriais_df != error)
                var territorios_seriais := seriais_df.GetProp("territorios");
                if (!territorios_seriais)
                    territorios_seriais := dictionary{};
                endif
                
                territorios_seriais[territorio_id] := struct{
                    "bau" := chest ? chest.serial : 0,
                    "mesa" := table ? table.serial : 0,
                    "mural" := mural ? mural.serial : 0,
                    "faction" := new_faction
                };
                
                seriais_df.SetProp("territorios", territorios_seriais);
            else
                DesfazerTransacao(transaction_id);
                DestroyItem(chest);
                DestroyItem(table);
                DestroyItem(mural);
                SendSysMessage(who, "Erro ao registrar seriais. Transferência revertida.");
                return 0;
            endif
        else
            DesfazerTransacao(transaction_id);
            SendSysMessage(who, "Erro: Coordenadas inválidas para o território.");
            return 0;
        endif
        
        // ===== ETAPA 5: NOTIFICAR O CONTROLADOR DE RECURSOS =====
        NotificarControladorRecursos(territorio_nome);
        
        // Finalizar a transação com sucesso
        FinalizarTransacao(transaction_id);
        
        SendSysMessage(who, "Território transferido com sucesso para " + new_faction + "!");
        return 1; // Indica que deve sair do gump
    endif
    
    return 0;
endfunction


// Nova função para atualizar os objetos físicos do território
function AtualizarObjetosDoTerritorio(territorio_id, old_faction, new_faction)
    LogDebug("territorio", "Iniciando atualização de objetos para território: " + territorio_id);
    LogDebug("territorio", "Alterando propriedade de facção de '" + old_faction + "' para '" + new_faction + "'");
    var seriais_df := SafeOpenDataFile(":faccao:seriais");
    // Tipos de objetos do território a serem atualizados
    var tipos_objetos := array{
        0xFF11, // Baú da facção
        0xFE5C, // Mesa de gestão
        0x46AE  // Mural de recrutamento
    };
    
    var objetos_encontrados := 0;
    var objetos_atualizados := 0;
    
    // MÉTODO 1: Verificar registros de seriais
    var rect_df := SafeOpenDataFile(":architect:areas");
    var seriais_encontrados := 0;
    var seriais_dict := dictionary{};
    
    if (seriais_df != error)
        seriais_dict := seriais_df.GetProp("territorios");
        if (!seriais_dict || seriais_dict == error)
            seriais_dict := dictionary{};
        endif
        
        if (seriais_dict && seriais_dict[territorio_id])
    LogDebug("territorio", "Encontrados seriais registrados para este território: " + territorio_id);
    var info := seriais_dict[territorio_id];
    
    // Atualizar baú
    if (info.bau)
        var bau := SystemFindObjectBySerial(CInt(info.bau));
        if (bau)
            LogDebug("territorio", "Atualizando baú (Serial: " + bau.serial + ")");
            // Atualizar propriedades
            PrintTextAbove(bau, "*Atualizando propriedades*");
            Sleep(1);
            SetObjProperty(bau, OBJ_FACTION_PROP, new_faction);
            SetObjProperty(bau, "FactionName", new_faction);
            
            // ATUALIZAÇÃO IMPORTANTE: Atualizar faction_chest_id
            var chest_id := new_faction + "_" + territorio_id;
            SetObjProperty(bau, CHEST_ID_PROP, chest_id);
            LogDebug("territorio", "Atualizado faction_chest_id para: " + chest_id);
            
            // Atualizar nome
            var nome_base := "Baú de Doações de " + new_faction;
            if (territorio_id)
                nome_base += " - " + territorio_id;
            endif
            LogDebug("territorio", "Renomeando para: " + nome_base);
            SetName(bau, nome_base);
            objetos_atualizados += 1;
            seriais_encontrados += 1;
            PrintTextAbove(bau, "*Atualizado para " + new_faction + "*");
        else
            LogError("territorio", "ERRO - Baú não encontrado pelo serial: " + info.bau);
        endif
    endif
            
          // Atualizar mesa
if (info.mesa)
    var mesa := SystemFindObjectBySerial(CInt(info.mesa));
    if (mesa)
        LogDebug("territorio", "Atualizando mesa (Serial: " + mesa.serial + ")");
        // Atualizar propriedades
        PrintTextAbove(mesa, "*Atualizando propriedades*");
        Sleep(1);
        SetObjProperty(mesa, OBJ_FACTION_PROP, new_faction);
        SetObjProperty(mesa, "FactionName", new_faction);
        // Atualizar nome
        var nome_mesa := "Mesa de Gestão de " + new_faction;
        if (territorio_id)
            nome_mesa += " - " + territorio_id;
        endif
        LogDebug("territorio", "Renomeando para: " + nome_mesa);
        SetName(mesa, nome_mesa);
        objetos_atualizados += 1;
        seriais_encontrados += 1;
        PrintTextAbove(mesa, "*Atualizado para " + new_faction + "*");
    else
        LogError("territorio", "ERRO - Mesa não encontrada pelo serial: " + info.mesa);
    endif
endif

// Atualizar mural
if (info.mural)
    var mural := SystemFindObjectBySerial(CInt(info.mural));
    if (mural)
        LogDebug("territorio", "Atualizando mural (Serial: " + mural.serial + ")");
        // Atualizar propriedades
        PrintTextAbove(mural, "*Atualizando propriedades*");
        Sleep(1);
        SetObjProperty(mural, OBJ_FACTION_PROP, new_faction);
        SetObjProperty(mural, "FactionName", new_faction);
        // Atualizar nome
        var nome_mural := "Mural de Recrutamento de " + new_faction;
        if (territorio_id)
            nome_mural += " - " + territorio_id;
        endif
        LogDebug("territorio", "Renomeando para: " + nome_mural);
        SetName(mural, nome_mural);
        objetos_atualizados += 1;
        seriais_encontrados += 1;
        PrintTextAbove(mural, "*Atualizado para " + new_faction + "*");
    else
        LogError("territorio", "ERRO - Mural não encontrado pelo serial: " + info.mural);
    endif
endif

// Atualizar informações de serial
seriais_dict[territorio_id].faction := new_faction;
seriais_df.SetProp("territorios", seriais_dict);
LogDebug("territorio", "Atualizadas informações no datafile de seriais");
else
    LogWarning("territorio", "Não foram encontrados registros de seriais para este território");
endif
else
    LogError("territorio", "AVISO - Não foi possível acessar o datafile de seriais");
endif

// MÉTODO 2: Busca por propriedades nos objetos do mundo
LogDebug("territorio", "Buscando objetos no mundo...");
    
    // Força a busca no mundo mesmo se encontrou pelos seriais
    var busca_x_objetos := 0;
    var objetos_por_mundo := 0;
    
    foreach item in EnumerateItemsInContainer(0) // 0 = root container
        sleepms(1); // Para não sobrecarregar o servidor
        
        // Verificar se é um dos tipos relevantes e limitar busca a 1000 itens para não travar
        if ((item.objtype in tipos_objetos) && (busca_x_objetos < 1000))
            busca_x_objetos += 1;
            
            // Verificar se pertence ao território
            var item_territory_id := GetObjProperty(item, TERRITORY_ID_PROP);
            var item_faction := GetObjProperty(item, OBJ_FACTION_PROP);
            var item_name := item.name;
            
            // Verificar por ID, facção ou nome
            if ((item_territory_id && item_territory_id == territorio_id) || 
                (item_faction && item_faction == old_faction) ||
                (item_name && (item_name.find(territorio_id) != error || item_name.find(old_faction) != error)))
                objetos_encontrados += 1;
LogDebug("territorio", "Objeto encontrado - Tipo: " + item.objtype + ", Serial: " + item.serial);
LogDebug("territorio", "Propriedades atuais - Nome: " + item_name + ", Facção: " + item_faction + ", ID: " + item_territory_id);

// Verificar se já foi atualizado pelos seriais
var ja_atualizado := 0;

if (seriais_df != error && seriais_dict && seriais_dict[territorio_id])
    var info := seriais_dict[territorio_id];
    if ((info.bau && CInt(item.serial) == CInt(info.bau)) || 
        (info.mesa && CInt(item.serial) == CInt(info.mesa)) || 
        (info.mural && CInt(item.serial) == CInt(info.mural)))
        ja_atualizado := 1;
    endif
endif

if (!ja_atualizado)
    // Atualizar facção do objeto
    PrintTextAbove(item, "*Atualizando propriedades*");
    Sleep(1);
    SetObjProperty(item, OBJ_FACTION_PROP, new_faction);
    SetObjProperty(item, "FactionName", new_faction);
    
    // Definir TERRITÓRIO_ID_PROP explicitamente (caso não tenha)
    if (!item_territory_id)
        SetObjProperty(item, TERRITORY_ID_PROP, territorio_id);
    endif
    
    // ADICIONADO: Atualizar faction_chest_id para baús
    if (item.objtype == 0xFF11) // Baú da facção
        var chest_id := new_faction + "_" + territorio_id;
        SetObjProperty(item, CHEST_ID_PROP, chest_id);
        LogDebug("territorio", "Atualizado faction_chest_id para: " + chest_id);
    endif
    
    if (item.objtype == 0xFF11) // Baú da facção
        // Verificação adicional - limpar todas as propriedades relacionadas à facção antiga
        foreach prop_name in (GetObjPropertyNames(item))
            if (prop_name.find("faction") != error || prop_name.find("Faction") != error)
                // Guardar o valor para logging
                var old_value := GetObjProperty(item, prop_name);
                LogDebug("territorio", "Propriedade " + prop_name + " com valor " + old_value);
                
                // Atualizar para nova facção
                SetObjProperty(item, prop_name, new_faction);
                LogDebug("territorio", "Atualizada para " + new_faction);
            endif
        endforeach
        
        // Forçar atualização de chest_id em formato padronizado
        var chest_id := new_faction + "_" + territorio_id;
        SetObjProperty(item, "faction_chest_id", chest_id);
        LogDebug("territorio", "Atualizado faction_chest_id (verificação adicional) para: " + chest_id);
        
        // Limpar cache do baú (se existir)
        EraseObjProperty(item, "cache_faction");
        EraseObjProperty(item, "last_accessed");
    endif

    // Atualizar nome com base no tipo de objeto
    var nome := "";
    case (item.objtype)
        0xFF11: nome := "Baú de Doações de " + new_faction; break;
        0xFE5C: nome := "Mesa de Gestão de " + new_faction; break;
        0x46AE: nome := "Mural de Recrutamento de " + new_faction; break;
    endcase
    
    if (territorio_id)
        nome += " - " + territorio_id;
    endif
    
    if (nome != "")
        LogDebug("territorio", "Renomeando para: " + nome);
        SetName(item, nome);
    endif
    
    // Registrar os seriais se não estiverem registrados
    if (seriais_df != error)
        if (!seriais_dict[territorio_id])
            seriais_dict[territorio_id] := struct{};
        endif
        
        case (item.objtype)
            0xFF11: seriais_dict[territorio_id].bau := item.serial; break;
            0xFE5C: seriais_dict[territorio_id].mesa := item.serial; break;
            0x46AE: seriais_dict[territorio_id].mural := item.serial; break;
        endcase
        
        seriais_dict[territorio_id].faction := new_faction;
        seriais_df.SetProp("territorios", seriais_dict);
        LogDebug("territorio", "Salvo serial do objeto no datafile");
    endif
    
   objetos_atualizados += 1;
objetos_por_mundo += 1;
PrintTextAbove(item, "*Propriedade transferida para " + new_faction + "*");
endif
            endif
        endif
    endforeach
    
    LogDebug("territorio", "Verificados " + busca_x_objetos + " objetos no mundo");
    LogDebug("territorio", "Encontrados " + objetos_por_mundo + " objetos adicionais no mundo");
    
    // MÉTODO 3: Última tentativa - busca por range de coordenadas
    if (objetos_atualizados == 0)
        LogDebug("territorio", "Tentando busca por coordenadas...");
        
        // Obter coordenadas do território
        var rect_df := SafeOpenDataFile(":architect:areas");
        if (rect_df)
            var elem_names := rect_df.keys();
            foreach elem_name in elem_names
                var elem := SafeFindElement(rect_df, elem_name);
                var elem_id := GetElementProp(elem, TERRITORY_ID_PROP, "");
                
                if (elem_id == territorio_id || elem_name == territorio_id)
                    var rect_str := GetElementProp(elem, "Rect", "");
                    var coords := SplitWords(rect_str);
                    
                    if (coords.size() >= 4)
                        var x1 := CInt(coords[1]);
                        var y1 := CInt(coords[2]);
                        var x2 := CInt(coords[3]);
                        var y2 := CInt(coords[4]);
                        var realm := GetElementProp(elem, "Realm", "");
                        
                        LogDebug("territorio", "Território encontrado - Coords: " + x1 + "," + y1 + " a " + x2 + "," + y2 + " em " + realm);
                        
                        // Buscar objetos na área
                        var objetos_por_coordenadas := 0;
                        
                        foreach item in ListItemsNearLocation(CInt((x1+x2)/2), CInt((y1+y2)/2), 0, 50, realm)
                            if (item.objtype in tipos_objetos)
                                // Verificar se já foi atualizado
                                if (GetObjProperty(item, OBJ_FACTION_PROP) != new_faction)
                                    PrintTextAbove(item, "*Atualizando por proximidade*");
                                    SetObjProperty(item, OBJ_FACTION_PROP, new_faction);
                                    SetObjProperty(item, "FactionName", new_faction);
                                    SetObjProperty(item, TERRITORY_ID_PROP, territorio_id);
                                    
                                    // ADICIONADO: Atualizar faction_chest_id para baús
                                    if (item.objtype == 0xFF11) // Baú da facção
                                        var chest_id := new_faction + "_" + territorio_id;
                                        SetObjProperty(item, CHEST_ID_PROP, chest_id);
                                        LogDebug("territorio", "Atualizado faction_chest_id para: " + chest_id);
                                    endif
                                    
                                    // Atualizar nome com base no tipo de objeto
                                    var nome := "";
                                    case (item.objtype)
                                        0xFF11: nome := "Baú de Doações de " + new_faction; break;
                                        0xFE5C: nome := "Mesa de Gestão de " + new_faction; break;
                                        0x46AE: nome := "Mural de Recrutamento de " + new_faction; break;
                                    endcase
                                    
                                    if (territorio_id)
                                        nome += " - " + territorio_id;
                                    endif
                                    
                                    if (nome != "")
                                        SetName(item, nome);
                                    endif
                                    
                                    objetos_atualizados += 1;
                                    objetos_por_coordenadas += 1;
                                    PrintTextAbove(item, "*Propriedade transferida para " + new_faction + "*");
                                    
                                    // Registrar serial
                                    if (seriais_df != error)
                                        if (!seriais_dict[territorio_id])
                                            seriais_dict[territorio_id] := struct{};
                                        endif
                                        
                                        case (item.objtype)
                                            0xFF11: seriais_dict[territorio_id].bau := item.serial; break;
                                            0xFE5C: seriais_dict[territorio_id].mesa := item.serial; break;
                                            0x46AE: seriais_dict[territorio_id].mural := item.serial; break;
                                        endcase
                                        
                                        seriais_dict[territorio_id].faction := new_faction;
                                        seriais_df.SetProp("territorios", seriais_dict);
                                    endif
                                endif
                            endif
                            Sleep(1);
                        endforeach
                        
                        LogDebug("territorio", "Encontrados " + objetos_por_coordenadas + " objetos por coordenadas");
                    endif
                    break;
                endif
                sleepms(2);
            endforeach
        endif
    endif
    
    LogDebug("territorio", "Resumo da atualização - Objetos encontrados via seriais: " + seriais_encontrados);
    LogDebug("territorio", "Objetos encontrados no total: " + objetos_encontrados);
    LogDebug("territorio", "Objetos atualizados no total: " + objetos_atualizados);
    
    return objetos_atualizados;
endfunction


function RevogarTerritorioFaccao(who, elem, territorio_info, faction)
    // Garantir compatibilidade com ambos os formatos
    var territorio_id := TypeOf(territorio_info) == "Struct" ? territorio_info.id : territorio_info;
    var territorio_nome := TypeOf(territorio_info) == "Struct" ? territorio_info.name : territorio_info;
    var seriais_df := SafeOpenDataFile(":faccao:seriais");
    
    if (YesNo(who, "Tem certeza que deseja revogar o controle de " + faction + " sobre este território?"))
        // Obter o realm do território para passar ao script de limpeza
        var territorio_realm := GetElementProp(elem, "Realm", "");
        if (!territorio_realm)
            territorio_realm := "britannia"; // Padrão se não encontrar
        endif
        
        LogDebug("territorio", "Iniciando remoção para território: " + territorio_id);
        LogDebug("territorio", "Facção: " + faction);
        LogDebug("territorio", "Realm: " + territorio_realm);
        LogDebug("territorio", "Nome: " + territorio_nome);
        
        // Verificar se temos os seriais armazenados
        var seriais_df := SafeOpenDataFile(":faccao:seriais");
        var territorios_seriais := dictionary{};
        
        if (seriais_df)
            territorios_seriais := seriais_df.GetProp("territorios");
        endif
        
        var seriais_encontrados := 0;
        
        // Se temos os seriais armazenados, remover diretamente 
        if (territorios_seriais && territorios_seriais[territorio_id])
            var info := territorios_seriais[territorio_id];
            
            LogDebug("territorio", "Seriais encontrados no registro para " + territorio_id);
            LogDebug("territorio", "Baú: " + info.bau);
            LogDebug("territorio", "Mesa: " + info.mesa);
            LogDebug("territorio", "Mural: " + info.mural);
            
            // Remover baú
            var bau := SystemFindObjectBySerial(info.bau);
            if (bau)
                LogDebug("territorio", "Destruindo baú: " + bau.name);
                DestroyItem(bau);
                seriais_encontrados += 1;
            endif
            
            // Remover mesa
            var mesa := SystemFindObjectBySerial(info.mesa);
            if (mesa)
                LogDebug("territorio", "Destruindo mesa: " + mesa.name);
                DestroyItem(mesa);
                seriais_encontrados += 1;
            endif
            
            // Remover mural
            var mural := SystemFindObjectBySerial(info.mural);
            if (mural)
                LogDebug("territorio", "Destruindo mural: " + mural.name);
                DestroyItem(mural);
                seriais_encontrados += 1;
            endif
            
            // Remover do dicionário
            territorios_seriais.Erase(territorio_id);
            seriais_df.SetProp("territorios", territorios_seriais);
            
            LogDebug("territorio", seriais_encontrados + " objetos destruídos diretamente pelos seriais.");
        else
            LogDebug("territorio", "Nenhum serial encontrado no registro, usando busca por área.");
        endif
        
        // Se não conseguiu remover todos os objetos, usar o script completo
        if (seriais_encontrados < 3)
            LogDebug("territorio", "Iniciando script de limpeza completa...");
            // Usar o script dedicado para limpar os objetos
            var script := start_script(":faccao:limpa_territorio", array{territorio_id, faction, who, territorio_realm});
            if (script == error)
                SendSysMessage(who, "Erro ao iniciar o script de limpeza: " + script);
                LogError("territorio", "Erro ao iniciar script: " + script);
            endif
        endif
        
        // Atualizar propriedades no datafile
        SetElementProp(elem, "Faction", DEFAULT_FACTION);
        SetElementProp(elem, TERRITORY_FACTION_PROP, DEFAULT_FACTION);
        elem.EraseProp("NextResourceTime");
        
        // Remover da lista de territórios da facção
        var fac_guildid := FindGuildByName(faction);
        if (fac_guildid)
            var guild := FindGuild(fac_guildid);
            if (guild)
                var territories := guild.GetProp("territories");
                if (territories)
                    // Procurar pelo ID ou pelo nome
                    var territory_index := 0;
                    for i := 1 to territories.size()
                        if ((TypeOf(territories[i]) == "Struct" && territories[i].id == territorio_id) ||
                            (TypeOf(territories[i]) == "String" && territories[i] == territorio_nome))
                            territory_index := i;
                            break;
                        endif
                    endfor
                    
                    if (territory_index > 0)
                        territories.Erase(territory_index);
                        guild.SetProp("territories", territories);
                        SendSysMessage(who, "Território removido da lista da facção.");
                    endif
                endif
            endif
        endif
        
        // Notificar o controlador de recursos
        NotificarControladorRecursos(territorio_nome);
        
        SendSysMessage(who, "Controle do território revogado com sucesso!");
        SendSysMessage(who, "Os objetos do território foram removidos.");
        return 1; // Indica que deve sair do gump
    endif
    
    return 1;
endfunction


// No início de cada ciclo do controlador

function NotificarControladorRecursos(territorio)
    // Esta função notifica o ResourceController sobre a revogação ou transferência
    LogDebug("territorio", "Tentando notificar o controlador de recursos para: " + territorio);
    
    // Tentar várias localizações possíveis para o datafile
    var df := SafeOpenDataFile(":system:messages");
    if (df == error)
        df := SafeOpenDataFile("messages");
        if (df == error)
            df := SafeOpenDataFile("messages", 1);
            if (df == error)
                LogError("territorio", "Não foi possível criar ou acessar o datafile de mensagens");
                return 0;
            endif
        endif
    endif
    
    if (df)
        LogDebug("territorio", "Datafile de mensagens encontrado");
        var elem := DFFindElement(df, "resource_controller", DF_CREATE);
        if (elem)
            var revocations := GetElementProp(elem, "revocations", 0);
            if (!revocations || revocations == error)
                revocations := array{};
                LogDebug("territorio", "Criando nova lista de notificações");
            else
                LogDebug("territorio", "Lista de notificações existente encontrada com " + revocations.size() + " itens");
            endif
            
            // Verificar se este território já está na lista
            var already_exists := 0;
            foreach terr in revocations
                if (terr == territorio)
                    already_exists := 1;
                    break;
                endif
            endforeach
            
            if (!already_exists)
                revocations.append(territorio);
                SetElementProp(elem, "revocations", revocations);
                LogDebug("territorio", "Território " + territorio + " adicionado à lista de notificações");
                return 1;
            else
                LogDebug("territorio", "Território " + territorio + " já está na lista de notificações");
                return 1;
            endif
        else
            LogError("territorio", "Não foi possível criar o elemento resource_controller");
        endif
    endif
    
    // Método alternativo - enviar mensagem para o controlador via events
    LogDebug("territorio", "Tentando notificar via evento do sistema");
    var ev := struct{
        "type" := "TerritoryChange",
        "territory" := territorio,
        "timestamp" := polcore().systime
    };
    
    // Tentar enviar evento para o controlador
    var pid := GetGlobalProperty("ResourceControllerPID");
    if (pid)
        var process := GetProcess(pid);
        if (process)
            process.SendEvent(ev);
            LogDebug("territorio", "Evento enviado para o controlador de recursos (PID: " + pid + ")");
            return 1;
        endif
    endif
    
    LogWarning("territorio", "Todas as tentativas de notificação falharam");
    return 0;
endfunction


function DestruirObjetosTerritorio(territorio_id, faction)
    var objetos_destruidos := 0;
    LogDebug("territorio", "Tentando destruir objetos para: " + territorio_id + ", facção: " + faction);
    
    // Buscando TODOS os objetos no mundo
    foreach item in EnumerateItemsInContainer(1)
        // Tipos de objetos do território
        if (item.objtype == 0xff11 || item.objtype == 0xFE5C || item.objtype == 0x46AE)
            // Verificar nome explicitamente
            var nome_item := item.name;
            if (nome_item.find(territorio_id) != error || nome_item.find(faction) != error)
                LogDebug("territorio", "Correspondência encontrada por nome: " + nome_item);
                // Tornar móvel e destruir em duas etapas separadas
                PrintTextAbove(item, "*Este objeto será removido*");
                item.movable := 1;
                Sleep(1);
                var destroy_result := DestroyItem(item);
                if (destroy_result)
                    objetos_destruidos += 1;
                    LogDebug("territorio", "Objeto destruído com sucesso");
                else
                    LogWarning("territorio", "Falha ao destruir objeto: " + destroy_result);
                    // Tentativa alternativa - mover para o void
                    MoveObjectToLocation(item, 6000, 6000, 0, "britannia_alt", MOVEOBJECT_FORCELOCATION);
                    objetos_destruidos += 1;
                    LogDebug("territorio", "Objeto movido para o void como alternativa");
                endif
                Sleep(2);
            else
                // Verificar propriedades
                var item_territory := GetObjProperty(item, TERRITORY_ID_PROP);
                var item_faction := GetObjProperty(item, OBJ_FACTION_PROP);
                
                if (item_territory == territorio_id || item_faction == faction)
                    LogDebug("territorio", "Correspondência encontrada por propriedade");
                    PrintTextAbove(item, "*Este objeto será removido*");
                    item.movable := 1;
                    Sleep(1);
                    var destroy_result := DestroyItem(item);
                    if (destroy_result)
                        objetos_destruidos += 1;
                        LogDebug("territorio", "Objeto destruído com sucesso");
                    else
                        LogWarning("territorio", "Falha ao destruir objeto: " + destroy_result);
                        // Tentativa alternativa - mover para o void
                        MoveObjectToLocation(item, 6000, 6000, 0, "britannia_alt", MOVEOBJECT_FORCELOCATION);
                        objetos_destruidos += 1;
                        LogDebug("territorio", "Objeto movido para o void como alternativa");
                    endif
                    Sleep(2);
                endif
            endif
        endif
    endforeach
    
    return objetos_destruidos;
endfunction



// Função auxiliar para verificar se uma constante está definida
function IsDefined(constant_name)
    if (!constant_name)
        return 0;
    endif
    
    case (constant_name)
        "UNIQUE_ID_PROP": return (TypeOf(UNIQUE_ID_PROP) != "error");
        "ITEM_TYPE_BAU": return (TypeOf(ITEM_TYPE_BAU) != "error");
        "ITEM_TYPE_MESA": return (TypeOf(ITEM_TYPE_MESA) != "error");
        "ITEM_TYPE_MURAL": return (TypeOf(ITEM_TYPE_MURAL) != "error");
        default: return 0;
    endcase
endfunction

function ShowPermissionsManagementGump(who, faction_name)
    // Verificação inicial de permissões
    if (!who.cmdlevel && !IsGuildLeader(who))
        SendSysMessage(who, "Apenas líderes de facção podem gerenciar permissões.");
        return 0;
    endif
    
    // Criar gump
    var gump := GFCreateGump();
    GFResizePic(gump, 0, 0, GFCfgConst("Defaults", "BackGround"), 500, 400);
    GFResizePic(gump, 15, 15, GFCfgConst("Defaults", "ForeGround"), 470, 370);
    
    // Título
    GFTextMid(gump, 10, 25, 480, 2100, "Gerenciamento de Permissões - " + faction_name);
    
    // Cabeçalho da lista
    var y := 60;
    GFTextLine(gump, 25, y, 2100, "Membros com Permissão Especial:");
    y += 25;
    
    // Buscar membros com permissão
    var guild := FindGuildByName(faction_name);
    if (!guild)
        return 0;
    endif
    
    var guild_obj := FindGuild(guild);
    if (!guild_obj)
        return 0;
    endif
    
    // Lista de permissões
    var special_permissions := guild_obj.GetProp("chest_permissions");
    if (!special_permissions)
        special_permissions := dictionary{};
    endif
    
    // Mostrar membros
    if (special_permissions.keys().size() > 0)
        foreach serial in (special_permissions.keys())
            var member := SystemFindObjectBySerial(serial, SYSFIND_SEARCH_OFFLINE_MOBILES);
            if (!member)
                continue;
            endif
            
            var permission := special_permissions[serial];
            GFTextLine(gump, 30, y, 2100, member.name + " - " + permission);
            GFAddButton(gump, 390, y, 2117, 2118, GF_CLOSE_BTN, 100 + _serial_iter);
            y += 25;
            sleepms(2);
        endforeach
    else
        GFTextLine(gump, 30, y, 2100, "Nenhum membro com permissão especial configurada.");
        y += 25;
    endif
    
    // Botão para adicionar novo
    y += 20;
    GFAddButton(gump, 25, y, 2117, 2118, GF_CLOSE_BTN, 1);
    GFTextLine(gump, 50, y, 2103, "Adicionar Permissão Especial para Membro");
    
    // Processar resposta
    var input := GFSendGump(who, gump);
    
    if (input[0] == 0)
        return 0;
    endif
    
    if (input[0] == 1)
        AddSpecialPermission(who, faction_name);
        return 1;
    endif
    
    if (input[0] >= 100)
        var index := input[0] - 100;
        var keys := special_permissions.keys();
        if (index >= 0 && index < keys.size())
            var serial := keys[index+1]; // POL usa arrays com base 1
            special_permissions.erase(serial);
            guild_obj.SetProp("chest_permissions", special_permissions);
            SendSysMessage(who, "Permissão especial removida.");
            ShowPermissionsManagementGump(who, faction_name);
        endif
    endif
    
    return 1;
endfunction