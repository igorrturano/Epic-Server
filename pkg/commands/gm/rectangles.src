use uo;
use os;
use datafile;
include ":gumps:gumps";
include ":gumps:gumps_ex";
include ":gumps:requestGump";
include ":gumps:yesNo";
include ":gumps:epicGumps";
include ":gumps:/include/epicGumps";
include ":faccao:faccao_constants";

program rectangle_creator(who, params)
    if (!who.cmdlevel)
        SendSysMessage(who, "Você não tem permissão para usar este comando.");
        return;
    endif
    

    
    // Abrir datafile apenas uma vez
    var rect_df := OpenDataFile(":architect:areas");
    
    // Verificar de migração: converter propriedades "Faction" para "faction"
    if (rect_df != error)
        foreach elem_name in (rect_df.keys())
            var elem := rect_df.FindElement(elem_name);
            var old_faction := elem.GetProp("Faction");
            if (old_faction)
                elem.SetProp(TERRITORY_FACTION_PROP, old_faction);
                elem.EraseProp("Faction");
            endif
        endforeach
    endif

    // Depois reutilizar a mesma variável sem o "var"
    if (rect_df == error)
        rect_df := CreateDataFile(":architect:areas");
        if (rect_df == error)
            SendSysMessage(who, "Erro ao criar arquivo de dados!");
            return;
        endif
    endif
    
    // Checar se o comando é para visualização direta
    params := Lower(params);
    if (params == "ver")
        ShowRectangles(who, rect_df);
        return;
    endif
    
    // Processo normal de criação de retângulo
    SendSysMessage(who, "Selecione o primeiro ponto (canto superior esquerdo)");
    var first_point := TargetCoordinates(who);
    if (!first_point)
        SendSysMessage(who, "Cancelado.");
        return;
    endif
    
    SendSysMessage(who, "Selecione o segundo ponto (canto inferior direito)");
    var second_point := TargetCoordinates(who);
    if (!second_point)
        SendSysMessage(who, "Cancelado.");
        return;
    endif
    
    // Organizar coordenadas para que x1,y1 seja o canto superior esquerdo
    // e x2,y2 seja o canto inferior direito
    var x1 := first_point.x;
    var y1 := first_point.y;
    var x2 := second_point.x;
    var y2 := second_point.y;
    
    if (x1 > x2)
        var temp := x1;
        x1 := x2;
        x2 := temp;
    endif
    
    if (y1 > y2)
        var temp := y1;
        y1 := y2;
        y2 := temp;
    endif
    
    var rect_str := $"{x1} {y1} {x2} {y2}";
    var realm := first_point.realm;
    
    // Mostrar o retângulo selecionado
    SendSysMessage(who, $"Retângulo definido: {rect_str} no realm {realm}");
    
    // Pedir o nome do retângulo
    var rect_name := RequestGump(who, "Digite um nome para este retângulo:");
    if (!rect_name || rect_name == "")
        SendSysMessage(who, "Operação cancelada - nome não fornecido.");
        return;
    endif
    
    // Verificar se o retângulo se sobrepõe a outro existente
    if (CheckRectangleOverlap(rect_df, x1, y1, x2, y2, realm, ""))
        SendSysMessage(who, "Este retângulo se sobrepõe a outro já existente.");
        SendSysMessage(who, "Operação cancelada.");
        return;
    endif
    
    // Verificar se o nome já existe e confirmar sobrescrita
    var elem := rect_df.FindElement(rect_name);
    if (elem)
        var confirm := YesNo(who, $"Já existe um retângulo com o nome '{rect_name}'. Sobrescrever?");
        if (!confirm)
            SendSysMessage(who, "Operação cancelada.");
            return;
        endif
    else
        elem := rect_df.CreateElement(rect_name);
    endif
    
    // Gerar e salvar um ID único para o território
var territory_id := CreateTerritoryID();
elem.SetProp(TERRITORY_ID_PROP, territory_id);

    // Salvar as informações do retângulo
    elem.SetProp("Name", rect_name);
    elem.SetProp("Rect", rect_str);
    elem.SetProp("Realm", realm);
    elem.SetProp(TERRITORY_FACTION_PROP, DEFAULT_FACTION); // Usar constante para facção padrão
    
    // Configurar recursos e intervalos para o território
    SetupResourcesForTerritory(who, elem);
    
    SendSysMessage(who, $"Retângulo '{rect_name}' salvo com sucesso!");
    
    // Opção para visualizar os retângulos existentes
    if (YesNo(who, "Deseja visualizar todos os retângulos salvos?"))
        ShowRectangles(who, rect_df);
    endif
endprogram

function SetupResourcesForTerritory(who, elem)
    // Lista de recursos disponíveis (sem repetições)
    var resource_sets := array{
        "IronOre",
        "couroespesso",
        "cogumelo",
        "madeirapinheiro",
        "carvao",
        "pelebranca",
        "madeirateixo",
        "prataIngot",
        "escamasazuis",
        "couropolar",
        "ossogigante",
        "ossodemoniaco",
        "courodraconiano",
        "acoIngot",
        "vidro",
        "osso",
        "couroescamoso"
    };
    
    // Remover duplicatas da lista de recursos
    var unique_resources := array{};
    var resource_dict := dictionary{};
    
    foreach resource in resource_sets
        // Converter para lowercase para comparação insensível a caso
        var lower_res := Lower(resource);
        if (!resource_dict.exists(lower_res))
            resource_dict[lower_res] := 1;
            unique_resources.append(resource);
        endif
    endforeach
    
    // Usar os recursos únicos daqui em diante
    resource_sets := unique_resources;
    
    // Recuperar valores atuais se existirem
    var current_interval := elem.GetProp("ResourceInterval") ? elem.GetProp("ResourceInterval") : 60;
    var current_amount := elem.GetProp("ResourceAmount") ? elem.GetProp("ResourceAmount") : 5;
    
    // Processar recursos atuais, garantindo que não haja entradas vazias e limitando a 3
    var current_resources := array{};
    if (elem.GetProp("Resources"))
        var resource_string := elem.GetProp("Resources");
        var raw_resources := SplitWords(resource_string, ",");
        
        var count := 0;
        foreach res in raw_resources
            // Limpar espaços extras
            res := TrimString(res);
            
            // Adicionar apenas recursos não vazios
            if (res != "" && count < 3)
                current_resources.append(res);
                count += 1;
            endif
            
            if (count >= 3)
                break;
            endif
        endforeach
    endif
    
    // Início do processo de seleção interativa
    var selected_resources := array{};
    
    // Inicializar com recursos atuais, se houver
    foreach res in current_resources
        selected_resources.append(res);
    endforeach
    
    var done := 0;
    while (!done)
        // Criar gump com as opções atuais
        var gump_data := CreateResourceGumpForTerritory(elem, resource_sets, selected_resources, current_interval, current_amount);
        var gump := gump_data.gump;
        var checkboxes := gump_data.checkboxes;
        
        var input := GFSendGump(who, gump);
        var button := input[0];
        
        // Se cancelou, encerrar sem salvar
        if (button == 0)
            return 0;
        endif
        
        if (button == 100)
            // Recuperar valores dos campos
            var interval := CInt(GFExtractData(input, 10));
            var amount := CInt(GFExtractData(input, 20));
            
            // Validar entradas
            if (interval < 1)
                interval := 1;
            endif
            
            if (amount < 1)
                amount := 1;
            endif
            
            // Processar recursos selecionados e atualizar interface se necessário
            var new_selections := array{};
            
            foreach checkbox in checkboxes
                if (input[checkbox.id])
                    new_selections.append(checkbox.resource);
                endif
            endforeach
            
            // Se mais de 3 seleções, mostrar mensagem e reabrir
            if (new_selections.size() > 3)
                SendSysMessage(who, "Você só pode selecionar até 3 recursos! Por favor, selecione novamente.");
                // Manter as 3 primeiras seleções
                selected_resources := array{};
                for i := 1 to 3
                    if (i <= new_selections.size())
                        selected_resources.append(new_selections[i]);
                    endif
                endfor
            else
                // Se 3 ou menos, salvar e encerrar
                // Converter lista de recursos em string
                var resources_str := "";
                for i := 1 to new_selections.size()
                    if (i > 1)
                        resources_str += ", ";
                    endif
                    resources_str += new_selections[i];
                endfor
                
                // Salvar no elemento
                elem.SetProp("ResourceInterval", interval);
                elem.SetProp("ResourceAmount", amount);
                elem.SetProp("Resources", resources_str);
                
                // Configurar próxima geração
                var next_time := polcore().systime + (interval * 60); // Converter minutos para segundos
                elem.SetProp("NextResourceTime", next_time);
                
                SendSysMessage(who, "Recursos configurados: " + resources_str);
                SendSysMessage(who, "Intervalo: " + interval + " minutos, Quantidade: " + amount + " unidades");
                
                done := 1;
            endif
        endif
    endwhile
    
    return 1;
endfunction

// Função separada para criar o gump de recursos
function CreateResourceGumpForTerritory(elem, resource_sets, selected_checkboxes, current_interval, current_amount)
    // Dimensões e configurações do gump
    var width := 500;
    var height := 470;
    var title := "Configurar Recursos para: " + elem.GetProp("Name");
    
    // Criar gump usando o estilo padronizado
    var gump := GFECreateGump(title, width, height, array{BORDER_GOLDEN});
    
    // Definir posição inicial
    var y := 70;
    var x := 30;
    
    // Intervalo de geração
    GFTextLine(gump, x, y, 2100, "Intervalo de Geração (minutos):");
    GFResizePic(gump, x + 230, y-5, 9350, 60, 30);
    GFTextEntry(gump, x + 235, y-3, 50, 25, 1153, current_interval, 10);
    y += 35;
    
    // Quantidade por geração
    GFTextLine(gump, x, y, 2100, "Quantidade por Geração:");
    GFResizePic(gump, x + 230, y-5, 9350, 60, 30);
    GFTextEntry(gump, x + 235, y-3, 50, 25, 1153, current_amount, 20);
    y += 35;
    
    // Título da seção de recursos - destaque para limite de 3
    GFTextLine(gump, x, y, 38, "Selecione até 3 recursos para o território:");
    y += 25;
    
    // Array para armazenar IDs dos checkboxes
    var checkboxes := array{};
    
    // Contador de recursos por coluna
    var items_per_column := 12;
    var current_column := 0;
    var current_item := 0;
    var base_y := y;
    
    // Adicionar recursos com checkboxes
    foreach resource in resource_sets
        // Verificar se o recurso está entre os selecionados
        var is_selected := 0;
        foreach selection in selected_checkboxes
            if (Lower(selection) == Lower(resource))
                is_selected := 1;
                break;
            endif
        endforeach
        
        // Calcular posição y baseada no item atual
        var pos_y := base_y + (current_item % items_per_column) * 20;
        
        // Calcular posição x baseada na coluna atual
        var pos_x := x + (current_column * 200);
        
        // ID do checkbox (300 + índice)
        var checkbox_id := 300 + checkboxes.size() + 1;
        
        // Adicionar checkbox
        GFCheckBox(gump, pos_x, pos_y, 9792, 9793, is_selected, checkbox_id);
        
        // Destacar os recursos selecionados com uma cor diferente
        var text_color := 1153; // Padrão
        if (is_selected)
            text_color := 63; // Verde para recursos selecionados
        endif
        GFTextLine(gump, pos_x + 20, pos_y, text_color, resource);
        
        // Armazenar informações sobre o checkbox
        checkboxes.append(struct{
            "id" := checkbox_id,
            "resource" := resource
        });
        
        // Incrementar contadores
        current_item += 1;
        if (current_item % items_per_column == 0)
            current_column += 1;
        endif
    endforeach
    
    // Posição y para os botões (abaixo de todas as colunas)
    y := base_y + ((items_per_column - 1) * 20) + 40;
    
    // Adicionar texto indicando quantos recursos selecionados
    var selection_count := selected_checkboxes.size();
    var selection_text := selection_count + "/3 recursos selecionados";
    GFTextLine(gump, width/2 - 80, y - 20, selection_count == 3 ? 63 : 38, selection_text);
    
    // Botões
    GFAddButton(gump, width/2 - 100, y, 2130, 2129, GF_CLOSE_BTN, 100);
    GFAddButton(gump, width/2 + 20, y, 0xF1, 0xF3, GF_CLOSE_BTN, 0);
    
    return struct{
        "gump" := gump,
        "checkboxes" := checkboxes
    };
endfunction

function ShowRectangles(who, rect_df)
    var width := 350;
    var height := 480;
    
    // Cria um gump padronizado usando a função GFECreateGump
    var gump := GFECreateGump("Gerenciador de Territórios", width, height, array{BORDER_GOLDEN});
    
    // Ajusta ponto inicial baseado na estrutura padrão do GFECreateGump
    var y := 70; // Posição abaixo do título
    var x := 30; // Margem interna
    
    // MODIFICAÇÃO: Posições fixas para "Territórios Registrados" e "Guilda"
    // Texto "Territórios Registrados" na posição x = 30
    GFTextLine(gump, 30, y, 53, "Territórios Registrados");
    
    // Texto "Guilda" na posição x = 280
    GFTextLine(gump, 280, y, 53, "Guilda");
    
    y += 25;
    
    var i := 1;
    
    // Cria uma tabela simples de territórios
    foreach rect_name in (rect_df.keys())
        var elem := rect_df.FindElement(rect_name);
        
        // Tratamento seguro para obter a facção
        var faction := "";
        var faction_property := elem.GetProp(TERRITORY_FACTION_PROP);
        
        if (faction_property && faction_property != error)
            // Verificar se não é um array ou struct
            if (TypeOf(faction_property) == "String")
                faction := faction_property;
            else
                // Tentar usar a propriedade legada
                faction := elem.GetProp("Faction");
                if (!faction || faction == error)
                    faction := DEFAULT_FACTION;
                else
                    // Atualizar para o formato padronizado
                    elem.SetProp(TERRITORY_FACTION_PROP, faction);
                endif
            endif
        else
            // Tentar usar a propriedade legada
            faction := elem.GetProp("Faction");
            if (!faction || faction == error)
                faction := DEFAULT_FACTION;
            else
                // Atualizar para o formato padronizado
                elem.SetProp(TERRITORY_FACTION_PROP, faction);
            endif
        endif
        
        // Define a cor baseada na facção - territórios selvagens em vermelho
        var color := 1153; // Padrão - azul claro
        if (faction == DEFAULT_FACTION)
            color := 38; // Vermelho
        endif
        
        // Botão e nome do território
        GFAddButton(gump, x, y+2, 2117, 2118, GF_CLOSE_BTN, 400+i);
        GFTextLine(gump, x+25, y, color, rect_name);
        
        // Exibe a facção controladora à direita, alinhada com "Guilda"
        GFTextLine(gump, 280, y, color, faction);
        
        y += 20;
        i += 1;
        
        // Evita que o gump fique muito grande - limita a 18 entradas por página
        if (i > 18)
            GFAddButton(gump, width/2, height-40, 2706, 2707, GF_CLOSE_BTN, 999);
            GFTextLine(gump, width/2+20, height-40, 1153, "Mais...");
            break;
        endif
    endforeach
    
    // Adiciona botão de criação para GMs - modificado para executar .rectangles 
    if (who.cmdlevel >= 1)
        GFAddButton(gump, width/2-70, height-40, 2361, 2361, GF_CLOSE_BTN, 300);
        GFTextLine(gump, width/2-50, height-44, 63, "Criar Novo Território");
    endif
    
    var input := GFSendGump(who, gump);
    var button := input[0];
    
    if (button >= 400 && button < 999)
        var index := button - 400;
        var rect_name := rect_df.keys()[index];
        var elem := rect_df.FindElement(rect_name);
        
        DisplayRectangleDetails(who, elem);
    elseif (button == 999)
        // Implementação de paginação para mostrar mais territórios
        ShowRectanglesPage2(who, rect_df, 19); // Começa do 19º item
    elseif (button == 300)
        // Modificado para executar o comando .rectangles
        SendSysMessage(who, "Executando o comando de criar novo território...");
        start_script(":commands:gm/rectangles", who);
    endif
endfunction

// Função adicional para mostrar mais territórios (também com posições fixas)
function ShowRectanglesPage2(who, rect_df, start_index)
    var width := 350;
    var height := 480;
    
    var gump := GFECreateGump("Gerenciador de Territórios - Página 2", width, height, array{BORDER_GOLDEN});
    
    var y := 70;
    var x := 30;
    
    // Títulos com posições fixas
    GFTextLine(gump, 30, y, 53, "Territórios Registrados");
    GFTextLine(gump, 280, y, 53, "Guilda");
    y += 25;
    
    var keys := rect_df.keys();
    var total := keys.size();
    var i := start_index;
    var displayed := 1;
    
    while (i <= total && displayed <= 18)
        var rect_name := keys[i];
        var elem := rect_df.FindElement(rect_name);
        var faction := elem.GetProp(TERRITORY_FACTION_PROP) ? elem.GetProp(TERRITORY_FACTION_PROP) : DEFAULT_FACTION;
        
        var color := 1153;
        if (faction == DEFAULT_FACTION)
            color := 38;
        endif
        
        // Elementos com posições ajustadas
        GFAddButton(gump, x-10+10, y+2, 2117, 2118, GF_CLOSE_BTN, 400+i);
        GFTextLine(gump, x+15+10, y, color, rect_name);
        GFTextLine(gump, 280, y, color, faction);
        
        y += 20;
        i += 1;
        displayed += 1;
    endwhile
    
    // Botão para voltar à primeira página
    GFAddButton(gump, width/2-70, height-40, 2704, 2705, GF_CLOSE_BTN, 998);
    GFTextLine(gump, width/2-50, height-40, 1153, "Página Anterior");
    
    var input := GFSendGump(who, gump);
    var button := input[0];
    
    if (button >= 400)
        var index := button - 400;
        var rect_name := keys[index];
        var elem := rect_df.FindElement(rect_name);
        
        DisplayRectangleDetails(who, elem);
    elseif (button == 998)
        // Voltar para a primeira página
        ShowRectangles(who, rect_df);
    endif
endfunction

// Função para verificar se um retângulo se sobrepõe a outro
function CheckRectangleOverlap(rect_df, x1, y1, x2, y2, realm, exclude_name := "")
    foreach rect_name in (rect_df.keys())
        // Pular a verificação se for o próprio retângulo que estamos editando
        if (rect_name == exclude_name)
            continue;
        endif
        
        var rect_elem := rect_df.FindElement(rect_name);
        var rect_realm := rect_elem.GetProp("Realm");
        
        // Se não estiver no mesmo realm, não há sobreposição
        if (rect_realm != realm)
            continue; 
        endif
        
        var rect_coords := SplitWords(rect_elem.GetProp("Rect"));
        if (rect_coords.size() < 4)
            continue; // Dados inválidos, pular
        endif
        
        var r_x1 := CInt(rect_coords[1]);
        var r_y1 := CInt(rect_coords[2]);
        var r_x2 := CInt(rect_coords[3]);
        var r_y2 := CInt(rect_coords[4]);
        
        // Verificar se há sobreposição
        // Dois retângulos não se sobrepõem se um está à esquerda, direita, acima ou abaixo do outro
        if (!(x2 < r_x1 || x1 > r_x2 || y2 < r_y1 || y1 > r_y2))
            return 1; // Há sobreposição
        endif
    endforeach
    
    return 0; // Não há sobreposição
endfunction

function DestruirObjetosTerritorio(territorio_id, faction)
    var objetos_destruidos := 0;
    
    // Tipos de objetos a serem destruídos
    var tipos_objetos := array{0xff11, 0xFE5C, 0x46AE}; // Baú, Mesa, Mural
    
    Print("DEBUG: Buscando objetos do território: " + territorio_id + " da facção: " + faction);
    
    foreach item in EnumerateItemsInContainer(1) // 1 = mundo
        if (item.objtype in tipos_objetos)
            var item_name := item.name;
            var item_territory_id := GetObjProperty(item, TERRITORY_ID_PROP);
            var item_faction := GetObjProperty(item, OBJ_FACTION_PROP);
            
            // Verificar se o item pertence ao território por nome ou propriedade
            if ((item_territory_id && item_territory_id == territorio_id) || 
                (item_name && item_name.find(territorio_id) != error) ||
                (item_faction && item_faction == faction))
                
                Print("DEBUG: Encontrado objeto: " + item.name + " (Serial: " + item.serial + ")");
                PrintTextAbove(item, "*Este objeto está sendo destruído*");
                
                // Tornar o item móvel para permitir a destruição
                item.movable := 1;
                Sleep(1); // Pausa para o servidor processar a mudança
                
                // Tentar destruir o item
                var destroy_result := DestroyItem(item);
                if (destroy_result)
                    objetos_destruidos += 1;
                    Print("DEBUG: Objeto destruído com sucesso");
                else
                    Print("DEBUG: Falha ao destruir objeto: " + destroy_result);
                    
                    // Se falhar, tentar método alternativo: mover para o void
                    MoveObjectToLocation(item, 6000, 6000, 0, "britannia_alt", MOVEOBJECT_FORCELOCATION);
                    objetos_destruidos += 1;
                    Print("DEBUG: Objeto movido para o void como alternativa");
                endif
                
                Sleep(2); // Pausa entre destruições
            endif
        endif
    endforeach
    
    return objetos_destruidos;
endfunction


function DisplayRectangleDetails(who, elem)
    var width := 400;
    var height := 380;
    
    var name := elem.GetProp("Name");
    var rect := elem.GetProp("Rect");
    var realm := elem.GetProp("Realm");
    var faction := elem.GetProp(TERRITORY_FACTION_PROP) ? elem.GetProp(TERRITORY_FACTION_PROP) : DEFAULT_FACTION;
    var resources := elem.GetProp("Resources") ? elem.GetProp("Resources") : "Não definidos";
    var interval := elem.GetProp("ResourceInterval") ? elem.GetProp("ResourceInterval") : 0;
    var amount := elem.GetProp("ResourceAmount") ? elem.GetProp("ResourceAmount") : 0;
    
    // Define a cor do título baseada na facção controladora
    var title_color := 53; // Dourado padrão
    if (faction == DEFAULT_FACTION)
        title_color := 38; // Vermelho para territórios selvagens
    endif
    
    // Título customizado com o nome do território
    var titulo := "Território: " + name;
    var gump := GFECreateGump(titulo, width, height, array{BORDER_GOLDEN});
    
    var y := 70;
    var x := 30;
    
    // Coordenadas do território
    GFTextLine(gump, x, y, 2100, "Coordenadas:");
    
    // Extrai e formata as coordenadas
    var coords := SplitWords(rect);
    var coords_text := "";
    if (coords.size() >= 4)
        coords_text := "(" + coords[1] + "," + coords[2] + ") a (" + coords[3] + "," + coords[4] + ")";
    else
        coords_text := rect;
    endif
    
    GFTextLine(gump, x+110, y, 63, coords_text);
    y += 25;
    
    // Informações do realm
    GFTextLine(gump, x, y, 2100, "Realm:");
    GFTextLine(gump, x+110, y, 63, realm);
    y += 25;
    
    // Facção controladora
    GFTextLine(gump, x, y, 2100, "Controlado por:");
    // Cor diferente dependendo se é selvagem ou controlado
    var control_color := 63; // Verde normal
    if (faction == DEFAULT_FACTION)
        control_color := 38; // Vermelho para selvagem
    endif
    GFTextLine(gump, x+110, y, control_color, faction);
    y += 25;
    
    // Linha de separação
    GFGumpPicTiled(gump, x, y, width-60, 2, 9101);
    y += 10;
    
    // Recursos do território
    GFTextLine(gump, x, y, 2100, "Recursos:");
    y += 20;
    
    if (resources != "Não definidos")
        // Limpar e processar a lista de recursos
        var resource_list := SplitWords(resources, ",");
        var clean_resources := array{};
        
        // Filtrar recursos vazios e limpar espaços extras
        foreach resource in resource_list
            // Remover espaços no início e fim
            resource := TrimString(resource);
            
            // Adicionar apenas recursos não vazios
            if (resource != "")
                clean_resources.append(resource);
            endif
        endforeach
        
        // Exibir os recursos limpos
        foreach resource in clean_resources
            GFTextLine(gump, x+20, y, 63, "• " + resource);
            y += 20;
        endforeach
        
        // Se não houver recursos válidos após a limpeza
        if (clean_resources.size() == 0)
            GFTextLine(gump, x+20, y, 38, "Nenhum recurso configurado");
            y += 25;
        else
            // Informações de geração
            y += 5;
            GFTextLine(gump, x, y, 2100, "Geração:");
            GFTextLine(gump, x+110, y, 63, amount + " a cada " + interval + " minutos");
            y += 20;
            
            // Verifica se tem informação de próxima geração
            var next_time := elem.GetProp("NextResourceTime");
            if (next_time)
                var time_left := next_time - polcore().systime;
                var minutes_left := CInt(time_left/60);
                
                if (minutes_left > 0)
                    GFTextLine(gump, x, y, 2100, "Próxima geração em:");
                    GFTextLine(gump, x+150, y, 63, minutes_left + " minutos");
                else
                    GFTextLine(gump, x, y, 2100, "Próxima geração:");
                    GFTextLine(gump, x+150, y, 38, "PENDENTE");
                endif
                y += 25;
            endif
        endif
    else
        GFTextLine(gump, x+20, y, 38, "Nenhum recurso configurado");
        y += 25;
    endif
    
    // Linha de separação
    GFGumpPicTiled(gump, x, y, width-60, 2, 9101);
    y += 15;
    
    // Botões de ações
    // Criar grid de 2x2 para os botões
    var btn_x := x + 20;
    var btn_y := y;
    var btn_spacing := 150;
    
    // Botão Ir para Território
    GFAddButton(gump, btn_x, btn_y, 2361, 2361, GF_CLOSE_BTN, 300);
    GFTextLine(gump, btn_x+20, btn_y-4, 1153, "Ir para Território");
    
    // Botão Configurar Recursos (somente para GMs)
    if (who.cmdlevel >= 1)
        GFAddButton(gump, btn_x+btn_spacing, btn_y, 2361, 2361, GF_CLOSE_BTN, 500);
        GFTextLine(gump, btn_x+btn_spacing+20, btn_y-4, 1153, "Configurar Recursos");
        
        btn_y += 25;
        
        // Botão Editar Território
        GFAddButton(gump, btn_x, btn_y, 2361, 2361, GF_CLOSE_BTN, 200);
        GFTextLine(gump, btn_x+20, btn_y-4, 1153, "Editar Território");
        
        // Botão Criar Totem
        GFAddButton(gump, btn_x+btn_spacing, btn_y, 2361, 2361, GF_CLOSE_BTN, 400);
        GFTextLine(gump, btn_x+btn_spacing+20, btn_y-4, 1153, "Criar Totem");
        
        btn_y += 25;
        
        // Botão Deletar (separado visualmente)
        GFAddButton(gump, btn_x, btn_y, 2361, 2361, GF_CLOSE_BTN, 100);
        GFTextLine(gump, btn_x+20, btn_y-4, 38, "Deletar Território");
    endif
    

    
    var input := GFSendGump(who, gump);
    var button := input[0];
    
    if (button == 100) // Deletar
        if (YesNo(who, "Tem certeza que deseja deletar o território '" + name + "'?"))
            // Primeiro, destruir os objetos do território, se houver
            var faction := elem.GetProp(TERRITORY_FACTION_PROP);
            if (!faction || faction == error)
                faction := elem.GetProp("Faction");  // Compatibilidade legada
            endif
            
            var territory_id := elem.GetProp(TERRITORY_ID_PROP);
            if (territory_id && faction)
                DestruirObjetosTerritorio(territory_id, faction);
            endif
            
            // Agora deletar o território
            var rect_df := OpenDataFile(":architect:areas");
            rect_df.DeleteElement(name);
            SendSysMessage(who, "Território deletado com sucesso!");
        endif
    elseif (button == 200) // Editar
        // Implementação existente para editar território
        SendSysMessage(who, "Selecione novos pontos para o território");
        
        SendSysMessage(who, "Selecione o primeiro ponto (canto superior esquerdo)");
        var first_point := TargetCoordinates(who);
        if (!first_point)
            SendSysMessage(who, "Edição cancelada.");
            return;
        endif
        
        SendSysMessage(who, "Selecione o segundo ponto (canto inferior direito)");
        var second_point := TargetCoordinates(who);
        if (!second_point)
            SendSysMessage(who, "Edição cancelada.");
            return;
        endif
        
        // Organizar coordenadas
        var x1 := first_point.x;
        var y1 := first_point.y;
        var x2 := second_point.x;
        var y2 := second_point.y;
        
        if (x1 > x2)
            var temp := x1;
            x1 := x2;
            x2 := temp;
        endif
        
        if (y1 > y2)
            var temp := y1;
            y1 := y2;
            y2 := temp;
        endif
        
        var rect_str := $"{x1} {y1} {x2} {y2}";
        
        // Verificar sobreposição
        if (CheckRectangleOverlap(OpenDataFile(":architect:areas"), x1, y1, x2, y2, first_point.realm, name))
            SendSysMessage(who, "Este território se sobrepõe a outro já existente.");
            SendSysMessage(who, "Edição cancelada.");
            return;
        endif
        
        // Atualizar elemento
        elem.SetProp("Rect", rect_str);
        elem.SetProp("Realm", first_point.realm);
        
        SendSysMessage(who, $"Território '{name}' atualizado!");
    elseif (button == 300) // Ir para território
        var coords := SplitWords(rect);
        if (coords.size() >= 4)
            var x1 := CInt(coords[1]);
            var y1 := CInt(coords[2]);
            var x2 := CInt(coords[3]);
            var y2 := CInt(coords[4]);
            
            var center_x := CInt((x1 + x2) / 2);
            var center_y := CInt((y1 + y2) / 2);
            var center_z := GetWorldHeight(center_x, center_y, realm);
            
            MoveObjectToLocation(who, center_x, center_y, center_z, realm, MOVEOBJECT_FORCELOCATION);
            SendSysMessage(who, "Teleportado para o centro do território!");
        else
            SendSysMessage(who, "Erro ao analisar as coordenadas do território!");
        endif
    elseif (button == 400) // Criar Totem
        CreateTerritoryTotem(who, elem);
    elseif (button == 500) // Configurar Recursos
        SetupResourcesForTerritory(who, elem);
    endif
endfunction

function CreateTerritoryTotem(who, elem)
    var totem := CreateItemInBackpack(who, 0xA102, 1); // TotemDeAquisicao
    if (!totem)
        SendSysMessage(who, "Falha ao criar o totem. Verifique o espaço na sua mochila.");
        return 0;
    endif
    
    // Obter o ID do território ou criar um se não existir
    var territory_id := elem.GetProp(TERRITORY_ID_PROP);
    if (!territory_id)
        territory_id := CreateTerritoryID();
        elem.SetProp(TERRITORY_ID_PROP, territory_id);
    endif
    
    // Configurar propriedades do totem
    SetObjProperty(totem, TERRITORY_NAME_PROP, elem.GetProp("Name"));
    SetObjProperty(totem, TERRITORY_RECT_PROP, elem.GetProp("Rect"));
    SetObjProperty(totem, TERRITORY_REALM_PROP, elem.GetProp("Realm"));
    SetObjProperty(totem, TERRITORY_ID_PROP, territory_id);  // Salvar o ID
    SetObjProperty(totem, "CreatedBy", who.serial);
    SetObjProperty(totem, "CreationDate", polcore().systime);
    
    SendSysMessage(who, "Um totem para o território '" + elem.GetProp("Name") + "' foi criado em sua mochila.");
    return 1;
endfunction

// Função TrimString consolidada (use apenas esta versão)
function TrimString(str)
    // Verificar se a string é vazia ou nula
    if (!str || str == "")
        return "";
    endif
    
    // Remove espaços no início
    while (str.length() > 0 && str[1] == " ")
        str := str[2, str.length()];
    endwhile
    
    // Remove espaços no fim
    while (str.length() > 0 && str[str.length()] == " ")
        str := str[1, str.length()-1];
    endwhile
    
    return str;
endfunction

// Função para gerar um ID único para o território
function CreateTerritoryID()
    // Combinar o timestamp com um número aleatório para garantir unicidade
    return "TER_" + polcore().systime + "_" + RandomInt(10000);
endfunction